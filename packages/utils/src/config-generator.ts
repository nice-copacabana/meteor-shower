// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 实现ConfigGenerator模板驱动替换硬编码，使用实际模板文件渲染配置

/**
 * 配置生成器模块
 * 基于模板和变量生成具体的配置操作计划
 *
 * 核心功能：
 * - 模板渲染：将模板转换为具体配置
 * - 操作规划：生成文件操作序列
 * - 多工具支持：为不同工具生成相应配置
 */

import { TemplateEngine, TemplateMetadata } from './template-engine.js';
import { FileOperations } from './file-ops.js';
import chalk from 'chalk';                 // 终端颜色输出
import fs from 'fs/promises';              // 文件系统操作
import path from 'path';                   // 路径操作
import os from 'os';                       // 操作系统信息

/**
 * 配置计划接口
 * 定义配置生成的结果和执行计划
 */
export interface ConfigPlan {
  toolset: string[];                        // 目标工具集
  template: string;                         // 使用的模板ID
  variables: Record<string, unknown>;       // 变量值
  operations: Array<{                       // 具体的文件操作序列
    target: string;                         // 目标工具类型
    path: string;                           // 目标文件路径
    content: string;                        // 文件内容
    kind: 'create' | 'update' | 'delete';   // 操作类型
  }>;
}

/**
 * 配置生成器类
 * 负责将模板和变量转换为具体的配置操作计划
 *
 * 工作流程：
 * 1. 加载和验证模板
 * 2. 为每个目标工具生成配置
 * 3. 生成文件操作序列
 * 4. 返回完整的配置计划
 */
export class ConfigGenerator {
  private templateEngine: TemplateEngine;   // 模板引擎实例
  private fileOps: FileOperations;          // 文件操作实例

  /**
   * 构造函数
   * 初始化模板引擎和文件操作实例
   */
  constructor() {
    this.templateEngine = new TemplateEngine();
    this.fileOps = new FileOperations();
  }

  /**
   * 生成配置计划
   * 基于工具集、模板和变量生成完整的配置操作计划
   *
   * @param toolset 目标工具集合
   * @param templateId 模板ID
   * @param variables 变量映射
   * @returns 完整的配置计划，包含所有文件操作
   */
  async generateConfig(toolset: string[], templateId: string, variables: Record<string, unknown>): Promise<ConfigPlan> {
    console.log(chalk.cyan('🔧 生成配置计划...'));

    // 加载并验证模板
    const template = await this.templateEngine.loadTemplate(templateId);
    const operations: ConfigPlan['operations'] = [];

    // 为每个目标工具生成对应的配置操作
    for (const tool of toolset) {
      console.log(chalk.gray(`  📦 处理 ${tool} 配置...`));
      const configs = await this.generateToolConfig(tool, template, variables);
      operations.push(...configs);
    }

    console.log(chalk.green(`✅ 生成 ${operations.length} 个配置操作`));
    return {
      toolset,
      template: templateId,
      variables,
      operations
    };
  }

  /**
   * 为指定工具生成配置操作
   * 基于模板文件和变量渲染配置内容
   *
   * @param tool 工具名称
   * @param template 模板元数据
   * @param variables 变量映射
   * @returns 该工具的配置操作列表
   */
  private async generateToolConfig(tool: string, template: TemplateMetadata, variables: Record<string, unknown>) {
    const operations: ConfigPlan['operations'] = [];
    
    // 根据工具类型定义配置文件映射
    const configMappings: Record<string, Array<{templateFile: string, targetPath: string}>> = {
      gemini: [
        { templateFile: 'GEMINI.md.template', targetPath: '~/.gemini/GEMINI.md' },
        { templateFile: 'settings.json.template', targetPath: '~/.gemini/settings.json' },
        { templateFile: 'plan.toml.template', targetPath: '.gemini/commands/plan.toml' }
      ],
      claude: [
        { templateFile: 'claude.json.template', targetPath: '~/.claude/claude.json' },
        { templateFile: 'CLAUDE.md.template', targetPath: './CLAUDE.md' },
        { templateFile: 'CLAUDE.local.md.template', targetPath: './CLAUDE.local.md' }
      ],
      cursor: [
        { templateFile: 'cursorrules.template', targetPath: './.cursorrules' },
        { templateFile: 'cursor-rules.txt.template', targetPath: './.cursor/rules.txt' },
        { templateFile: 'CURSOR.local.md.template', targetPath: './CURSOR.local.md' }
      ],
      openai: [
        { templateFile: 'AGENTS.md.template', targetPath: './AGENTS.md' },
        { templateFile: 'env.example.template', targetPath: './.env.example' },
        { templateFile: 'OPENAI.local.md.template', targetPath: './OPENAI.local.md' }
      ]
    };

    const mappings = configMappings[tool];
    if (!mappings) {
      console.warn(chalk.yellow(`⚠️ 未知工具类型: ${tool}，跳过`));
      return operations;
    }

    // 为每个模板文件生成操作
    for (const mapping of mappings) {
      try {
        const content = await this.renderTemplateFile(tool, mapping.templateFile, variables);
        operations.push({
          target: tool,
          path: mapping.targetPath,
          content,
          kind: 'create'
        });
      } catch (error) {
        console.error(chalk.red(`❌ 渲染模板失败 ${mapping.templateFile}: ${error}`));
      }
    }
    
    return operations;
  }

  /**
   * 渲染模板文件
   * 读取模板文件并使用变量进行渲染
   *
   * @param tool 工具名称
   * @param templateFileName 模板文件名
   * @param variables 变量映射
   * @returns 渲染后的内容
   */
  private async renderTemplateFile(tool: string, templateFileName: string, variables: Record<string, unknown>): Promise<string> {
    // 构建模板文件路径
    const templatePath = path.join(
      process.cwd(),
      'packages/templates/configs',
      tool,
      templateFileName
    );

    try {
      // 读取模板文件
      let content = await fs.readFile(templatePath, 'utf-8');

      // 进行变量替换
      content = this.replaceVariables(content, variables);

      return content;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        console.warn(chalk.yellow(`⚠️ 模板文件不存在: ${templatePath}`));
        // 返回基本的占位符内容
        return this.generateFallbackContent(tool, templateFileName, variables);
      }
      throw error;
    }
  }

  /**
   * 替换模板中的变量
   * 支持简单的 {{variableName}} 格式
   * 支持 Handlebars 的 {{#each}} 循环语法
   *
   * @param content 模板内容
   * @param variables 变量映射
   * @returns 替换后的内容
   */
  private replaceVariables(content: string, variables: Record<string, unknown>): string {
    let result = content;

    // 处理 {{#each techStack}} 循环
    const eachRegex = /\{\{#each (\w+)\}\}([\s\S]*?)\{\{\/each\}\}/g;
    result = result.replace(eachRegex, (match, arrayName, template) => {
      const array = variables[arrayName];
      if (!Array.isArray(array)) {
        return '';
      }
      return array.map(item => template.replace(/\{\{this\}\}/g, String(item))).join('');
    });

    // 处理 {{#if condition}} 条件
    const ifRegex = /\{\{#if (\w+(?:\.\w+)?)\}\}([\s\S]*?)\{\{\/if\}\}/g;
    result = result.replace(ifRegex, (match, condition, content) => {
      // 支持 features.database 这样的嵌套访问
      const keys = condition.split('.');
      let value: any = variables;
      for (const key of keys) {
        value = value?.[key];
      }
      return value ? content : '';
    });

    // 处理简单变量 {{variableName}}
    for (const [key, value] of Object.entries(variables)) {
      const placeholder = new RegExp(`\\{\\{${key}\\}\\}`, 'g');
      result = result.replace(placeholder, String(value));
    }

    return result;
  }

  /**
   * 生成备用内容
   * 当模板文件不存在时，生成简单的占位符内容
   *
   * @param tool 工具名称
   * @param templateFileName 模板文件名
   * @param variables 变量映射
   * @returns 占位符内容
   */
  private generateFallbackContent(tool: string, templateFileName: string, variables: Record<string, unknown>): string {
    const projectName = variables.projectName || 'my-project';
    const persona = variables.persona || '你是一名资深工程师';

    return `# ${projectName} - ${tool.toUpperCase()} 配置

<!-- 生成自备用模板，请创建实际模板文件: ${templateFileName} -->

## 角色定义
${persona}

## 项目信息
- 项目名称: ${projectName}
- 工具: ${tool}

## 编码规范
- 保持代码简洁
- 遵循最佳实践
- 编写单元测试
`;
  }
}
