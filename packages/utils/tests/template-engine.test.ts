// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: ä¸ºTemplateEngineè¡¥å……å•å…ƒæµ‹è¯•

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TemplateEngine, TemplateMetadata } from '../src/template-engine.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('TemplateEngine', () => {
  let engine: TemplateEngine;
  let testDir: string;
  let samplesDir: string;

  beforeEach(async () => {
    // åˆ›å»ºä¸´æ—¶æµ‹è¯•ç›®å½•
    testDir = path.join(os.tmpdir(), `template-test-${Date.now()}`);
    samplesDir = path.join(testDir, 'packages', 'templates', 'samples');
    await fs.mkdir(samplesDir, { recursive: true });

    // åˆ‡æ¢åˆ°æµ‹è¯•ç›®å½•
    process.chdir(testDir);

    // åˆå§‹åŒ– TemplateEngine
    engine = new TemplateEngine();
  });

  afterEach(async () => {
    // æ¸…ç†æµ‹è¯•ç›®å½•
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // å¿½ç•¥æ¸…ç†é”™è¯¯
    }
  });

  describe('loadTemplate', () => {
    it('should load valid template successfully', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'test-template',
        name: 'Test Template',
        version: '1.0.0',
        targets: ['gemini', 'claude'],
        variables: {
          projectName: 'string',
          persona: 'string'
        }
      };
      
      const templatePath = path.join(samplesDir, 'test-template.json');
      await fs.writeFile(templatePath, JSON.stringify(template), 'utf-8');

      // Act
      const loaded = await engine.loadTemplate('test-template');

      // Assert
      expect(loaded).toEqual(template);
      expect(loaded.id).toBe('test-template');
      expect(loaded.targets).toContain('gemini');
    });

    it('should throw error when template file not found', async () => {
      // Act & Assert
      await expect(
        engine.loadTemplate('nonexistent-template')
      ).rejects.toThrow();
    });

    it('should throw error when template JSON is invalid', async () => {
      // Arrange
      const invalidPath = path.join(samplesDir, 'invalid.json');
      await fs.writeFile(invalidPath, 'invalid json {', 'utf-8');

      // Act & Assert
      await expect(
        engine.loadTemplate('invalid')
      ).rejects.toThrow();
    });

    it('should load template without schema validation when schema file missing', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'no-schema',
        name: 'No Schema Template',
        version: '1.0.0',
        targets: ['cursor'],
        variables: {}
      };
      
      const templatePath = path.join(samplesDir, 'no-schema.json');
      await fs.writeFile(templatePath, JSON.stringify(template), 'utf-8');

      // Act
      const loaded = await engine.loadTemplate('no-schema');

      // Assert
      expect(loaded).toEqual(template);
    });
  });

  describe('renderTemplate', () => {
    it('should replace simple variables in template', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'render-test',
        name: '{{projectName}} Template',
        version: '1.0.0',
        targets: ['{{tool}}'],
        variables: {
          projectName: '{{projectName}}',
          tool: '{{tool}}'
        }
      };

      const variables = {
        projectName: 'MyProject',
        tool: 'gemini'
      };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('MyProject Template');
      expect(result.targets).toContain('gemini');
      expect(result.variables.projectName).toBe('MyProject');
    });

    it('should replace multiple occurrences of same variable', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'multi-replace',
        name: '{{name}} - {{name}}',
        version: '{{name}}',
        targets: [],
        variables: {
          name: '{{name}}'
        }
      };

      const variables = { name: 'test' };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('test - test');
      expect(result.version).toBe('test');
      expect(result.variables.name).toBe('test');
    });

    it('should handle empty variables object', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'empty-vars',
        name: 'Static Template',
        version: '1.0.0',
        targets: ['claude'],
        variables: {}
      };

      // Act
      const rendered = await engine.renderTemplate(template, {});
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('Static Template');
    });

    it('should convert non-string values to strings', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'type-convert',
        name: 'Version {{version}}',
        version: '1.0.0',
        targets: [],
        variables: {
          count: '{{count}}',
          enabled: '{{enabled}}'
        }
      };

      const variables = {
        version: 123,
        count: 456,
        enabled: true
      };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('Version 123');
      expect(result.variables.count).toBe('456');
      expect(result.variables.enabled).toBe('true');
    });

    it('should leave unreplaced variables as placeholders', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'partial-replace',
        name: '{{replaced}} - {{notReplaced}}',
        version: '1.0.0',
        targets: [],
        variables: {}
      };

      const variables = {
        replaced: 'value'
      };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('value - {{notReplaced}}');
    });
  });

  describe('listTemplates', () => {
    it('should list all valid templates in samples directory', async () => {
      // Arrange
      const template1: TemplateMetadata = {
        id: 'template1',
        name: 'Template 1',
        version: '1.0.0',
        targets: ['gemini'],
        variables: {}
      };

      const template2: TemplateMetadata = {
        id: 'template2',
        name: 'Template 2',
        version: '1.0.0',
        targets: ['claude'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'template1.json'),
        JSON.stringify(template1),
        'utf-8'
      );
      await fs.writeFile(
        path.join(samplesDir, 'template2.json'),
        JSON.stringify(template2),
        'utf-8'
      );

      // Act
      const templates = await engine.listTemplates();

      // Assert
      expect(templates).toHaveLength(2);
      expect(templates.map(t => t.id)).toContain('template1');
      expect(templates.map(t => t.id)).toContain('template2');
    });

    it('should return empty array when no templates exist', async () => {
      // Act
      const templates = await engine.listTemplates();

      // Assert
      expect(templates).toEqual([]);
    });

    it('should skip invalid template files', async () => {
      // Arrange
      const validTemplate: TemplateMetadata = {
        id: 'valid',
        name: 'Valid',
        version: '1.0.0',
        targets: [],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'valid.json'),
        JSON.stringify(validTemplate),
        'utf-8'
      );
      await fs.writeFile(
        path.join(samplesDir, 'invalid.json'),
        'invalid json',
        'utf-8'
      );

      // Act
      const templates = await engine.listTemplates();

      // Assert
      expect(templates).toHaveLength(1);
      expect(templates[0].id).toBe('valid');
    });

    it('should ignore non-JSON files', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'only-template',
        name: 'Only Template',
        version: '1.0.0',
        targets: [],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'only-template.json'),
        JSON.stringify(template),
        'utf-8'
      );
      await fs.writeFile(
        path.join(samplesDir, 'readme.md'),
        '# README',
        'utf-8'
      );
      await fs.writeFile(
        path.join(samplesDir, 'config.txt'),
        'config',
        'utf-8'
      );

      // Act
      const templates = await engine.listTemplates();

      // Assert
      expect(templates).toHaveLength(1);
      expect(templates[0].id).toBe('only-template');
    });
  });

  describe('Schema validation', () => {
    it('should validate template against schema when available', async () => {
      // Arrange - åˆ›å»º schema æ–‡ä»¶
      const schemaDir = path.join(testDir, 'packages', 'templates', 'schemas');
      await fs.mkdir(schemaDir, { recursive: true });

      const schema = {
        type: 'object',
        required: ['id', 'name', 'version', 'targets', 'variables'],
        properties: {
          id: { type: 'string' },
          name: { type: 'string' },
          version: { type: 'string' },
          targets: { type: 'array' },
          variables: { type: 'object' }
        }
      };

      await fs.writeFile(
        path.join(schemaDir, 'template.schema.json'),
        JSON.stringify(schema),
        'utf-8'
      );

      const validTemplate: TemplateMetadata = {
        id: 'valid-schema',
        name: 'Valid Schema Template',
        version: '1.0.0',
        targets: ['gemini'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'valid-schema.json'),
        JSON.stringify(validTemplate),
        'utf-8'
      );

      // Act
      const loaded = await engine.loadTemplate('valid-schema');

      // Assert
      expect(loaded).toEqual(validTemplate);
    });
  });

  describe('Edge cases', () => {
    it('should handle template with special characters', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'special-chars',
        name: '{{name}} - "Test" & <Special>',
        version: '1.0.0',
        targets: [],
        variables: {}
      };

      const variables = { name: 'Project' };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('Project - "Test" & <Special>');
    });

    it('should handle nested JSON structures', async () => {
      // Arrange
      const complexTemplate = {
        id: 'complex',
        name: 'Complex',
        version: '1.0.0',
        targets: [],
        variables: {},
        config: {
          nested: {
            value: '{{nestedValue}}'
          }
        }
      } as any;

      const variables = { nestedValue: 'deep value' };

      // Act
      const rendered = await engine.renderTemplate(complexTemplate, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.config.nested.value).toBe('deep value');
    });

    it('should handle Unicode characters', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'unicode',
        name: '{{name}} - ä¸­æ–‡æµ‹è¯• ðŸš€',
        version: '1.0.0',
        targets: [],
        variables: {}
      };

      const variables = { name: 'é¡¹ç›®' };

      // Act
      const rendered = await engine.renderTemplate(template, variables);
      const result = JSON.parse(rendered);

      // Assert
      expect(result.name).toBe('é¡¹ç›® - ä¸­æ–‡æµ‹è¯• ðŸš€');
    });
  });
});
