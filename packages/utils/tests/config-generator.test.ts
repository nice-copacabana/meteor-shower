// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 为ConfigGenerator补充单元测试

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { ConfigGenerator, ConfigPlan } from '../src/config-generator.js';
import { TemplateMetadata } from '../src/template-engine.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('ConfigGenerator', () => {
  let generator: ConfigGenerator;
  let testDir: string;
  let samplesDir: string;
  let configsDir: string;

  beforeEach(async () => {
    // 创建临时测试目录
    testDir = path.join(os.tmpdir(), `config-gen-test-${Date.now()}`);
    samplesDir = path.join(testDir, 'packages', 'templates', 'samples');
    configsDir = path.join(testDir, 'packages', 'templates', 'configs');
    
    await fs.mkdir(samplesDir, { recursive: true });
    await fs.mkdir(configsDir, { recursive: true });

    // 切换到测试目录
    process.chdir(testDir);

    // 初始化 ConfigGenerator
    generator = new ConfigGenerator();
  });

  afterEach(async () => {
    // 清理测试目录
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('generateConfig', () => {
    it('should generate config plan for single tool', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'test-template',
        name: 'Test Template',
        version: '1.0.0',
        targets: ['gemini'],
        variables: {
          projectName: 'string',
          persona: 'string'
        }
      };

      await fs.writeFile(
        path.join(samplesDir, 'test-template.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // 创建 gemini 模板目录和文件
      const geminiDir = path.join(configsDir, 'gemini');
      await fs.mkdir(geminiDir, { recursive: true });
      await fs.writeFile(
        path.join(geminiDir, 'GEMINI.md.template'),
        '# {{projectName}} - Gemini Config\n{{persona}}',
        'utf-8'
      );

      const variables = {
        projectName: 'TestProject',
        persona: 'You are a senior engineer'
      };

      // Act
      const plan = await generator.generateConfig(['gemini'], 'test-template', variables);

      // Assert
      expect(plan).toBeDefined();
      expect(plan.toolset).toEqual(['gemini']);
      expect(plan.template).toBe('test-template');
      expect(plan.variables).toEqual(variables);
      expect(plan.operations.length).toBeGreaterThan(0);
    });

    it('should generate config plan for multiple tools', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'multi-tool',
        name: 'Multi Tool Template',
        version: '1.0.0',
        targets: ['gemini', 'claude', 'cursor'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'multi-tool.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // 创建各工具模板目录
      for (const tool of ['gemini', 'claude', 'cursor']) {
        const toolDir = path.join(configsDir, tool);
        await fs.mkdir(toolDir, { recursive: true });
      }

      // Act
      const plan = await generator.generateConfig(
        ['gemini', 'claude', 'cursor'],
        'multi-tool',
        { projectName: 'Test' }
      );

      // Assert
      expect(plan.toolset).toHaveLength(3);
      expect(plan.operations.length).toBeGreaterThan(0);
    });

    it('should replace variables in template content', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'variable-test',
        name: 'Variable Test',
        version: '1.0.0',
        targets: ['claude'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'variable-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      const claudeDir = path.join(configsDir, 'claude');
      await fs.mkdir(claudeDir, { recursive: true });
      await fs.writeFile(
        path.join(claudeDir, 'CLAUDE.md.template'),
        '# {{projectName}}\n\n{{persona}}\n\nStyle: {{codingStyle}}',
        'utf-8'
      );

      const variables = {
        projectName: 'MyApp',
        persona: 'Expert developer',
        codingStyle: 'clean-code'
      };

      // Act
      const plan = await generator.generateConfig(['claude'], 'variable-test', variables);

      // Assert
      const claudeOps = plan.operations.filter(op => op.target === 'claude');
      expect(claudeOps.length).toBeGreaterThan(0);
      
      const mdOp = claudeOps.find(op => op.path.includes('CLAUDE.md'));
      expect(mdOp).toBeDefined();
      expect(mdOp!.content).toContain('MyApp');
      expect(mdOp!.content).toContain('Expert developer');
      expect(mdOp!.content).toContain('clean-code');
    });

    it('should handle {{#each}} loops in templates', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'loop-test',
        name: 'Loop Test',
        version: '1.0.0',
        targets: ['openai'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'loop-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      const openaiDir = path.join(configsDir, 'openai');
      await fs.mkdir(openaiDir, { recursive: true });
      await fs.writeFile(
        path.join(openaiDir, 'AGENTS.md.template'),
        '# Tech Stack\n{{#each techStack}}\n- {{this}}\n{{/each}}',
        'utf-8'
      );

      const variables = {
        techStack: ['TypeScript', 'Node.js', 'React']
      };

      // Act
      const plan = await generator.generateConfig(['openai'], 'loop-test', variables);

      // Assert
      const agentsOp = plan.operations.find(op => op.path.includes('AGENTS.md'));
      expect(agentsOp).toBeDefined();
      expect(agentsOp!.content).toContain('- TypeScript');
      expect(agentsOp!.content).toContain('- Node.js');
      expect(agentsOp!.content).toContain('- React');
    });

    it('should handle {{#if}} conditionals in templates', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'conditional-test',
        name: 'Conditional Test',
        version: '1.0.0',
        targets: ['cursor'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'conditional-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      const cursorDir = path.join(configsDir, 'cursor');
      await fs.mkdir(cursorDir, { recursive: true });
      await fs.writeFile(
        path.join(cursorDir, 'cursorrules.template'),
        '# Config\n{{#if features.database}}\n- Database enabled\n{{/if}}',
        'utf-8'
      );

      const variables = {
        features: { database: true }
      };

      // Act
      const plan = await generator.generateConfig(['cursor'], 'conditional-test', variables);

      // Assert
      const rulesOp = plan.operations.find(op => op.path.includes('cursorrules'));
      expect(rulesOp).toBeDefined();
      expect(rulesOp!.content).toContain('- Database enabled');
    });

    it('should use fallback content when template file not found', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'missing-template',
        name: 'Missing Template',
        version: '1.0.0',
        targets: ['gemini'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'missing-template.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // 不创建模板文件

      const variables = {
        projectName: 'FallbackTest'
      };

      // Act
      const plan = await generator.generateConfig(['gemini'], 'missing-template', variables);

      // Assert
      expect(plan.operations.length).toBeGreaterThan(0);
      const op = plan.operations[0];
      expect(op.content).toContain('FallbackTest');
      expect(op.content).toContain('备用模板');
    });

    it('should skip unknown tool types', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'unknown-tool',
        name: 'Unknown Tool',
        version: '1.0.0',
        targets: ['unknown-tool'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'unknown-tool.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // Act
      const plan = await generator.generateConfig(['unknown-tool'], 'unknown-tool', {});

      // Assert
      expect(plan.operations).toHaveLength(0);
    });
  });

  describe('Operation generation', () => {
    it('should generate correct file paths for each tool', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'paths-test',
        name: 'Paths Test',
        version: '1.0.0',
        targets: ['gemini', 'claude', 'cursor', 'openai'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'paths-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // 创建所有工具模板目录
      for (const tool of ['gemini', 'claude', 'cursor', 'openai']) {
        const toolDir = path.join(configsDir, tool);
        await fs.mkdir(toolDir, { recursive: true });
      }

      // Act
      const plan = await generator.generateConfig(
        ['gemini', 'claude', 'cursor', 'openai'],
        'paths-test',
        {}
      );

      // Assert
      const geminiOps = plan.operations.filter(op => op.target === 'gemini');
      const claudeOps = plan.operations.filter(op => op.target === 'claude');
      const cursorOps = plan.operations.filter(op => op.target === 'cursor');
      const openaiOps = plan.operations.filter(op => op.target === 'openai');

      expect(geminiOps.some(op => op.path.includes('~/.gemini'))).toBe(true);
      expect(claudeOps.some(op => op.path.includes('~/.claude') || op.path.includes('CLAUDE'))).toBe(true);
      expect(cursorOps.some(op => op.path.includes('.cursor') || op.path.includes('cursorrules'))).toBe(true);
      expect(openaiOps.some(op => op.path.includes('AGENTS.md'))).toBe(true);
    });

    it('should mark all operations as "create" kind', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'kind-test',
        name: 'Kind Test',
        version: '1.0.0',
        targets: ['claude'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'kind-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      const claudeDir = path.join(configsDir, 'claude');
      await fs.mkdir(claudeDir, { recursive: true });

      // Act
      const plan = await generator.generateConfig(['claude'], 'kind-test', {});

      // Assert
      expect(plan.operations.every(op => op.kind === 'create')).toBe(true);
    });
  });

  describe('Error handling', () => {
    it('should throw error when template not found', async () => {
      // Act & Assert
      await expect(
        generator.generateConfig(['gemini'], 'nonexistent', {})
      ).rejects.toThrow();
    });

    it('should handle template read errors gracefully', async () => {
      // Arrange
      const template: TemplateMetadata = {
        id: 'error-test',
        name: 'Error Test',
        version: '1.0.0',
        targets: ['claude'],
        variables: {}
      };

      await fs.writeFile(
        path.join(samplesDir, 'error-test.json'),
        JSON.stringify(template),
        'utf-8'
      );

      const claudeDir = path.join(configsDir, 'claude');
      await fs.mkdir(claudeDir, { recursive: true });
      
      // 创建一个无效的模板文件（没有读权限的目录）
      const invalidPath = path.join(claudeDir, 'invalid');
      await fs.mkdir(invalidPath, { recursive: true });

      // Act - 应该使用 fallback content
      const plan = await generator.generateConfig(['claude'], 'error-test', {});

      // Assert
      expect(plan).toBeDefined();
    });
  });

  describe('Integration tests', () => {
    it('should generate complete config plan for real-world scenario', async () => {
      // Arrange - 创建真实的模板和配置
      const template: TemplateMetadata = {
        id: 'full-stack-app',
        name: 'Full Stack App Template',
        version: '1.0.0',
        targets: ['gemini', 'claude', 'cursor'],
        variables: {
          projectName: 'string',
          persona: 'string',
          techStack: 'array',
          codingStyle: 'string'
        }
      };

      await fs.writeFile(
        path.join(samplesDir, 'full-stack-app.json'),
        JSON.stringify(template),
        'utf-8'
      );

      // 创建各工具模板
      const geminiDir = path.join(configsDir, 'gemini');
      const claudeDir = path.join(configsDir, 'claude');
      const cursorDir = path.join(configsDir, 'cursor');

      await fs.mkdir(geminiDir, { recursive: true });
      await fs.mkdir(claudeDir, { recursive: true });
      await fs.mkdir(cursorDir, { recursive: true });

      await fs.writeFile(
        path.join(geminiDir, 'GEMINI.md.template'),
        '# {{projectName}}\n{{persona}}\n{{#each techStack}}\n- {{this}}\n{{/each}}',
        'utf-8'
      );

      await fs.writeFile(
        path.join(claudeDir, 'CLAUDE.md.template'),
        '# {{projectName}} - Claude\n{{persona}}',
        'utf-8'
      );

      await fs.writeFile(
        path.join(cursorDir, 'cursorrules.template'),
        '# {{projectName}} Rules\nStyle: {{codingStyle}}',
        'utf-8'
      );

      const variables = {
        projectName: 'E-Commerce Platform',
        persona: 'You are an expert full-stack developer',
        techStack: ['React', 'Node.js', 'PostgreSQL', 'Redis'],
        codingStyle: 'functional'
      };

      // Act
      const plan = await generator.generateConfig(
        ['gemini', 'claude', 'cursor'],
        'full-stack-app',
        variables
      );

      // Assert
      expect(plan.toolset).toHaveLength(3);
      expect(plan.template).toBe('full-stack-app');
      expect(plan.variables).toEqual(variables);
      expect(plan.operations.length).toBeGreaterThanOrEqual(3);

      // 验证变量替换正确
      const geminiOp = plan.operations.find(op => 
        op.target === 'gemini' && op.path.includes('GEMINI.md')
      );
      expect(geminiOp).toBeDefined();
      expect(geminiOp!.content).toContain('E-Commerce Platform');
      expect(geminiOp!.content).toContain('- React');
      expect(geminiOp!.content).toContain('- PostgreSQL');

      const cursorOp = plan.operations.find(op => 
        op.target === 'cursor' && op.path.includes('cursorrules')
      );
      expect(cursorOp).toBeDefined();
      expect(cursorOp!.content).toContain('functional');
    });
  });
});
