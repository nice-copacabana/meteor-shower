// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-17
// Task: 实现QuotaManager配额管理器，管理用户配额使用和限制

/**
 * 配额管理器V2
 * 
 * 根据设计文档实现配额检查、使用统计和重置功能
 */

import Database from 'better-sqlite3';
import { randomUUID } from 'crypto';
import { QuotaUsageModel } from './database/models.js';
import { UserTierManagerV2, TIER_FEATURES, UserTier } from './user-tier-manager-v2.js';

/**
 * 资源类型
 */
export type ResourceType = 'TOOL' | 'CLOUD_TEMPLATE' | 'VALIDATION' | 'CONCURRENT_TASK' | 'STORAGE';

/**
 * 配额检查结果
 */
export interface QuotaCheckResult {
  allowed: boolean;
  remaining: number;
  limit: number;
  used: number;
  resetAt: Date;
}

/**
 * 配额管理器V2
 */
export class QuotaManagerV2 {
  private userTierManager: UserTierManagerV2;

  constructor(private db: Database.Database) {
    this.userTierManager = new UserTierManagerV2(db);
  }

  /**
   * 获取用户配额记录
   */
  private getQuotaUsage(userId: string, resourceType: ResourceType): QuotaUsageModel | null {
    const stmt = this.db.prepare(`
      SELECT * FROM quota_usage 
      WHERE user_id = ? AND resource_type = ?
      ORDER BY created_at DESC
      LIMIT 1
    `);
    return stmt.get(userId, resourceType) as QuotaUsageModel | null;
  }

  /**
   * 创建配额记录
   */
  private createQuotaUsage(userId: string, resourceType: ResourceType, limit: number): QuotaUsageModel {
    const quotaId = randomUUID();
    const now = Date.now();
    
    // 计算下次重置时间（下个月1号）
    const resetDate = new Date();
    resetDate.setMonth(resetDate.getMonth() + 1);
    resetDate.setDate(1);
    resetDate.setHours(0, 0, 0, 0);
    
    const stmt = this.db.prepare(`
      INSERT INTO quota_usage (id, user_id, resource_type, used_count, limit_count, reset_at, created_at)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `);
    
    stmt.run(
      quotaId,
      userId,
      resourceType,
      0,
      limit,
      resetDate.getTime(),
      now
    );
    
    return this.getQuotaUsage(userId, resourceType)!;
  }

  /**
   * 获取或创建配额记录
   */
  private getOrCreateQuotaUsage(userId: string, resourceType: ResourceType): QuotaUsageModel {
    let quota = this.getQuotaUsage(userId, resourceType);
    
    if (!quota) {
      // 获取用户层级的限制
      const user = this.userTierManager.getUserById(userId);
      if (!user) {
        throw new Error(`User not found: ${userId}`);
      }
      
      const features = TIER_FEATURES[user.tier];
      const limit = this.getResourceLimit(resourceType, features);
      
      quota = this.createQuotaUsage(userId, resourceType, limit);
    }
    
    // 检查是否需要重置
    const now = Date.now();
    if (quota.reset_at < now) {
      this.resetQuota(userId, resourceType);
      quota = this.getQuotaUsage(userId, resourceType)!;
    }
    
    return quota;
  }

  /**
   * 根据资源类型获取限制值
   */
  private getResourceLimit(resourceType: ResourceType, features: typeof TIER_FEATURES[UserTier]): number {
    switch (resourceType) {
      case 'TOOL':
        return features.maxTools;
      case 'CLOUD_TEMPLATE':
        return features.maxCloudTemplates;
      case 'VALIDATION':
        return features.maxValidationRuns;
      case 'CONCURRENT_TASK':
        return 100; // 默认值，可根据层级调整
      case 'STORAGE':
        return 1024 * 1024 * 1024; // 1GB，可根据层级调整
      default:
        return 0;
    }
  }

  /**
   * 检查配额
   */
  checkQuota(userId: string, resourceType: ResourceType, requestCount: number = 1): QuotaCheckResult {
    const quota = this.getOrCreateQuotaUsage(userId, resourceType);
    
    const allowed = quota.limit_count === Infinity || 
                   (quota.used_count + requestCount <= quota.limit_count);
    
    return {
      allowed,
      remaining: quota.limit_count === Infinity ? Infinity : Math.max(0, quota.limit_count - quota.used_count),
      limit: quota.limit_count,
      used: quota.used_count,
      resetAt: new Date(quota.reset_at),
    };
  }

  /**
   * 使用配额
   */
  useQuota(userId: string, resourceType: ResourceType, amount: number = 1): boolean {
    const checkResult = this.checkQuota(userId, resourceType, amount);
    
    if (!checkResult.allowed) {
      return false;
    }
    
    const quota = this.getQuotaUsage(userId, resourceType)!;
    
    const stmt = this.db.prepare(`
      UPDATE quota_usage 
      SET used_count = used_count + ?
      WHERE id = ?
    `);
    
    stmt.run(amount, quota.id);
    
    return true;
  }

  /**
   * 减少配额使用（例如删除资源时）
   */
  releaseQuota(userId: string, resourceType: ResourceType, amount: number = 1): void {
    const quota = this.getQuotaUsage(userId, resourceType);
    
    if (!quota) {
      return;
    }
    
    const stmt = this.db.prepare(`
      UPDATE quota_usage 
      SET used_count = MAX(0, used_count - ?)
      WHERE id = ?
    `);
    
    stmt.run(amount, quota.id);
  }

  /**
   * 重置配额
   */
  resetQuota(userId: string, resourceType: ResourceType): void {
    const quota = this.getQuotaUsage(userId, resourceType);
    
    if (!quota) {
      return;
    }
    
    // 计算下次重置时间
    const resetDate = new Date();
    resetDate.setMonth(resetDate.getMonth() + 1);
    resetDate.setDate(1);
    resetDate.setHours(0, 0, 0, 0);
    
    const stmt = this.db.prepare(`
      UPDATE quota_usage 
      SET used_count = 0, reset_at = ?
      WHERE id = ?
    `);
    
    stmt.run(resetDate.getTime(), quota.id);
  }

  /**
   * 获取用户所有配额情况
   */
  getAllQuotas(userId: string): Record<ResourceType, QuotaCheckResult> {
    const resourceTypes: ResourceType[] = ['TOOL', 'CLOUD_TEMPLATE', 'VALIDATION', 'CONCURRENT_TASK', 'STORAGE'];
    
    const result: any = {};
    
    for (const resourceType of resourceTypes) {
      result[resourceType] = this.checkQuota(userId, resourceType, 0);
    }
    
    return result;
  }

  /**
   * 批量重置到期的配额
   */
  resetExpiredQuotas(): number {
    const now = Date.now();
    
    const stmt = this.db.prepare(`
      SELECT DISTINCT user_id, resource_type 
      FROM quota_usage 
      WHERE reset_at < ?
    `);
    
    const expiredQuotas = stmt.all(now) as Array<{ user_id: string; resource_type: ResourceType }>;
    
    for (const quota of expiredQuotas) {
      this.resetQuota(quota.user_id, quota.resource_type);
    }
    
    return expiredQuotas.length;
  }

  /**
   * 更新用户配额限制（当用户升级/降级时）
   */
  updateQuotaLimits(userId: string): void {
    const user = this.userTierManager.getUserById(userId);
    if (!user) {
      return;
    }
    
    const features = TIER_FEATURES[user.tier];
    const resourceTypes: ResourceType[] = ['TOOL', 'CLOUD_TEMPLATE', 'VALIDATION', 'CONCURRENT_TASK', 'STORAGE'];
    
    for (const resourceType of resourceTypes) {
      const quota = this.getQuotaUsage(userId, resourceType);
      if (quota) {
        const newLimit = this.getResourceLimit(resourceType, features);
        
        const stmt = this.db.prepare(`
          UPDATE quota_usage 
          SET limit_count = ?
          WHERE id = ?
        `);
        
        stmt.run(newLimit, quota.id);
      }
    }
  }

  /**
   * 获取配额使用统计
   */
  getQuotaStats(resourceType?: ResourceType): {
    totalUsers: number;
    overQuota: number;
    averageUsage: number;
  } {
    let whereClause = '';
    let params: any[] = [];
    
    if (resourceType) {
      whereClause = 'WHERE resource_type = ?';
      params.push(resourceType);
    }
    
    const statsStmt = this.db.prepare(`
      SELECT 
        COUNT(DISTINCT user_id) as totalUsers,
        COUNT(CASE WHEN used_count >= limit_count THEN 1 END) as overQuota,
        AVG(CAST(used_count AS FLOAT) / NULLIF(limit_count, 0)) as averageUsage
      FROM quota_usage
      ${whereClause}
    `);
    
    const stats = statsStmt.get(...params) as any;
    
    return {
      totalUsers: stats.totalUsers || 0,
      overQuota: stats.overQuota || 0,
      averageUsage: stats.averageUsage || 0,
    };
  }
}
