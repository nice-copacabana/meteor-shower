// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-15
// Task: M6 Phase4 - 支付管理器实现

import { DatabaseManager } from '../database/manager.js';
import {
  PaymentProvider,
  PaymentStatus,
  PaymentOrder,
  CreatePaymentRequest,
  PaymentResponse,
  PaymentCallback,
  PaymentGateway,
  PaymentConfig,
  PaymentMethod,
  Currency,
} from './payment-types.js';
import { nanoid } from 'nanoid';

/**
 * 支付管理器
 */
export class PaymentManager {
  private gateways: Map<PaymentProvider, PaymentGateway> = new Map();

  constructor(
    private dbManager: DatabaseManager,
    private config: PaymentConfig
  ) {
    this.initializeGateways();
  }

  /**
   * 初始化支付网关
   */
  private initializeGateways(): void {
    // TODO: 实际项目中需要初始化具体的支付网关实现
    // 这里先创建占位符网关
    if (this.config.alipay) {
      // this.gateways.set(PaymentProvider.ALIPAY, new AlipayGateway(this.config.alipay));
    }
    
    if (this.config.wechat) {
      // this.gateways.set(PaymentProvider.WECHAT, new WechatGateway(this.config.wechat));
    }
    
    if (this.config.stripe) {
      // this.gateways.set(PaymentProvider.STRIPE, new StripeGateway(this.config.stripe));
    }
  }

  /**
   * 创建支付订单
   */
  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {
    // 生成订单ID
    const orderId = `order_${Date.now()}_${nanoid(8)}`;
    
    // 创建支付订单记录
    const order: PaymentOrder = {
      id: orderId,
      userId: request.userId,
      subscriptionId: request.subscriptionId,
      provider: request.provider,
      method: request.method,
      amount: request.amount,
      currency: request.currency,
      title: request.title,
      description: request.description,
      status: PaymentStatus.PENDING,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 30 * 60 * 1000), // 30分钟后过期
      callbackUrl: request.callbackUrl,
      metadata: request.metadata,
    };

    // 保存订单到数据库
    await this.savePaymentOrder(order);

    // 获取对应的支付网关
    const gateway = this.gateways.get(request.provider);
    if (!gateway) {
      throw new Error(`不支持的支付提供商: ${request.provider}`);
    }

    // 调用支付网关创建支付
    try {
      const response = await gateway.createPayment(request);
      
      // 更新订单状态
      await this.updatePaymentStatus(orderId, PaymentStatus.PROCESSING);
      
      return {
        orderId,
        ...response,
      };
    } catch (error: any) {
      // 更新订单状态为失败
      await this.updatePaymentStatus(orderId, PaymentStatus.FAILED);
      throw error;
    }
  }

  /**
   * 查询支付状态
   */
  async queryPayment(orderId: string): Promise<PaymentOrder | null> {
    // 从数据库查询订单
    return this.getPaymentOrder(orderId);
  }

  /**
   * 处理支付回调
   */
  async handlePaymentCallback(
    provider: PaymentProvider,
    rawData: Record<string, any>
  ): Promise<void> {
    const gateway = this.gateways.get(provider);
    if (!gateway) {
      throw new Error(`不支持的支付提供商: ${provider}`);
    }

    // 验证回调签名
    if (!gateway.verifyCallback(rawData)) {
      throw new Error('回调签名验证失败');
    }

    // 解析回调数据
    const callback = await gateway.handleCallback(rawData);

    // 更新订单状态
    await this.updatePaymentOrder(callback.orderId, {
      status: callback.status,
      transactionId: callback.transactionId,
      paidAt: callback.paidAt,
    });

    // 如果支付成功，触发订阅激活
    if (callback.status === PaymentStatus.SUCCESS) {
      await this.activateSubscription(callback.orderId);
    }
  }

  /**
   * 取消支付
   */
  async cancelPayment(orderId: string): Promise<boolean> {
    const order = await this.getPaymentOrder(orderId);
    if (!order) {
      throw new Error('订单不存在');
    }

    // 只能取消待支付或处理中的订单
    if (order.status !== PaymentStatus.PENDING && order.status !== PaymentStatus.PROCESSING) {
      throw new Error(`订单状态不允许取消: ${order.status}`);
    }

    const gateway = this.gateways.get(order.provider);
    if (gateway) {
      await gateway.cancelPayment(orderId);
    }

    await this.updatePaymentStatus(orderId, PaymentStatus.CANCELLED);
    return true;
  }

  /**
   * 申请退款
   */
  async refundPayment(
    orderId: string,
    amount?: number,
    reason?: string
  ): Promise<boolean> {
    const order = await this.getPaymentOrder(orderId);
    if (!order) {
      throw new Error('订单不存在');
    }

    // 只能退款成功的订单
    if (order.status !== PaymentStatus.SUCCESS) {
      throw new Error(`订单状态不允许退款: ${order.status}`);
    }

    const gateway = this.gateways.get(order.provider);
    if (!gateway) {
      throw new Error(`不支持的支付提供商: ${order.provider}`);
    }

    // 默认全额退款
    const refundAmount = amount || order.amount;
    
    // 调用支付网关退款
    const success = await gateway.refund(orderId, refundAmount, reason);
    
    if (success) {
      await this.updatePaymentStatus(orderId, PaymentStatus.REFUNDED);
      
      // 如果有关联订阅，取消订阅
      if (order.subscriptionId) {
        await this.deactivateSubscription(order.subscriptionId);
      }
    }

    return success;
  }

  /**
   * 获取用户的支付记录
   */
  async getUserPayments(userId: string, limit: number = 10): Promise<PaymentOrder[]> {
    // TODO: 实现从数据库查询
    return [];
  }

  /**
   * 保存支付订单
   */
  private async savePaymentOrder(order: PaymentOrder): Promise<void> {
    // TODO: 保存到数据库
    // 实际项目中需要创建 payment_orders 表
  }

  /**
   * 获取支付订单
   */
  private async getPaymentOrder(orderId: string): Promise<PaymentOrder | null> {
    // TODO: 从数据库查询
    return null;
  }

  /**
   * 更新支付状态
   */
  private async updatePaymentStatus(orderId: string, status: PaymentStatus): Promise<void> {
    // TODO: 更新数据库
  }

  /**
   * 更新支付订单
   */
  private async updatePaymentOrder(
    orderId: string,
    updates: Partial<PaymentOrder>
  ): Promise<void> {
    // TODO: 更新数据库
  }

  /**
   * 激活订阅
   */
  private async activateSubscription(orderId: string): Promise<void> {
    const order = await this.getPaymentOrder(orderId);
    if (!order || !order.subscriptionId) {
      return;
    }

    // 更新订阅状态为活跃
    const subscription = this.dbManager.subscriptions.findById(order.subscriptionId);
    if (subscription) {
      this.dbManager.subscriptions.update(order.subscriptionId, {
        status: 'active',
        currentPeriodStart: new Date(),
        currentPeriodEnd: this.calculatePeriodEnd(subscription.billingCycle),
      });
    }
  }

  /**
   * 取消订阅
   */
  private async deactivateSubscription(subscriptionId: string): Promise<void> {
    this.dbManager.subscriptions.update(subscriptionId, {
      status: 'cancelled',
    });
  }

  /**
   * 计算订阅周期结束时间
   */
  private calculatePeriodEnd(billingCycle: string): Date {
    const now = new Date();
    
    if (billingCycle === 'monthly') {
      return new Date(now.setMonth(now.getMonth() + 1));
    } else if (billingCycle === 'yearly') {
      return new Date(now.setFullYear(now.getFullYear() + 1));
    }
    
    return new Date(now.setMonth(now.getMonth() + 1));
  }
}

/**
 * Mock支付网关 (用于测试)
 */
export class MockPaymentGateway implements PaymentGateway {
  async createPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {
    return {
      orderId: `mock_${Date.now()}`,
      paymentUrl: 'https://mock-payment.example.com/pay',
      qrCode: 'mock_qr_code_data',
    };
  }

  async queryPayment(orderId: string): Promise<PaymentOrder> {
    throw new Error('Mock实现，实际项目中需要实现');
  }

  async handleCallback(rawData: Record<string, any>): Promise<PaymentCallback> {
    return {
      orderId: rawData.orderId,
      provider: PaymentProvider.ALIPAY,
      status: PaymentStatus.SUCCESS,
      transactionId: 'mock_transaction_id',
      amount: rawData.amount,
      paidAt: new Date(),
      rawData,
    };
  }

  verifyCallback(rawData: Record<string, any>): boolean {
    // Mock实现总是返回true
    return true;
  }

  async cancelPayment(orderId: string): Promise<boolean> {
    return true;
  }

  async refund(orderId: string, amount: number, reason?: string): Promise<boolean> {
    return true;
  }
}
