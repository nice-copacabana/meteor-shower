// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-15
// Task: 实现数据库管理器，提供数据库初始化、迁移和连接管理功能

/**
 * 数据库管理器
 * 
 * 负责数据库的初始化、迁移、连接管理
 */

import Database from 'better-sqlite3';
import * as path from 'path';
import * as fs from 'fs';
import { initializeDatabase, MIGRATIONS } from './schema.js';
import { UserDAO, SubscriptionDAO, UsageStatsDAO, OrganizationDAO } from './dao.js';
import { AuditLogManager, AUDIT_LOG_SCHEMA } from '../permissions/audit-manager.js';

/**
 * 数据库管理器配置
 */
export interface DatabaseConfig {
  /** 数据库文件路径 */
  path: string;
  /** 是否为只读模式 */
  readonly?: boolean;
  /** 是否启用WAL模式 */
  wal?: boolean;
  /** 是否在内存中运行 */
  memory?: boolean;
}

/**
 * 迁移记录
 */
interface MigrationRecord {
  version: number;
  name: string;
  applied_at: number;
}

/**
 * 数据库管理器
 */
export class DatabaseManager {
  private db: Database.Database | null = null;
  private config: DatabaseConfig;

  // DAO实例
  public users!: UserDAO;
  public subscriptions!: SubscriptionDAO;
  public usageStats!: UsageStatsDAO;
  public organizations!: OrganizationDAO;
  public auditLogs!: AuditLogManager;

  constructor(config: DatabaseConfig) {
    this.config = config;
  }

  /**
   * 连接数据库
   */
  connect(): void {
    if (this.db) {
      console.warn('⚠️  数据库已连接');
      return;
    }

    // 如果不是内存数据库，确保目录存在
    if (!this.config.memory) {
      const dir = path.dirname(this.config.path);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    }

    // 创建数据库连接
    this.db = new Database(
      this.config.memory ? ':memory:' : this.config.path,
      {
        readonly: this.config.readonly || false,
        fileMustExist: false,
      }
    );

    // 启用WAL模式（提高并发性能）
    if (this.config.wal && !this.config.memory) {
      this.db.pragma('journal_mode = WAL');
    }

    // 初始化DAO
    this.users = new UserDAO(this.db);
    this.subscriptions = new SubscriptionDAO(this.db);
    this.usageStats = new UsageStatsDAO(this.db);
    this.organizations = new OrganizationDAO(this.db);
    this.auditLogs = new AuditLogManager(this.db);

    console.log('✅ 数据库连接成功');
  }

  /**
   * 初始化数据库（创建表）
   */
  initialize(): void {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    // 创建迁移记录表
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS migrations (
        version INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        applied_at INTEGER NOT NULL
      )
    `);

    // 初始化数据库结构
    initializeDatabase(this.db);
    
    // 创建审计日志表
    this.db.exec(AUDIT_LOG_SCHEMA);

    console.log('✅ 数据库初始化完成');
  }

  /**
   * 执行数据库迁移
   */
  migrate(): void {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    // 获取已应用的迁移
    const appliedMigrations = this.db
      .prepare('SELECT * FROM migrations ORDER BY version')
      .all() as MigrationRecord[];

    const appliedVersions = new Set(appliedMigrations.map(m => m.version));

    // 执行未应用的迁移
    for (const migration of MIGRATIONS) {
      if (!appliedVersions.has(migration.version)) {
        console.log(`📦 应用迁移: ${migration.name} (v${migration.version})`);
        
        // 在事务中执行迁移
        const transaction = this.db.transaction(() => {
          migration.up(this.db!);
          
          // 记录迁移
          this.db!.prepare(`
            INSERT INTO migrations (version, name, applied_at)
            VALUES (?, ?, ?)
          `).run(migration.version, migration.name, Date.now());
        });

        transaction();
        
        console.log(`✅ 迁移完成: ${migration.name}`);
      }
    }

    console.log('✅ 所有迁移已应用');
  }

  /**
   * 回滚迁移
   */
  rollback(targetVersion: number): void {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    const appliedMigrations = this.db
      .prepare('SELECT * FROM migrations ORDER BY version DESC')
      .all() as MigrationRecord[];

    for (const record of appliedMigrations) {
      if (record.version <= targetVersion) {
        break;
      }

      const migration = MIGRATIONS.find(m => m.version === record.version);
      if (!migration) {
        console.warn(`⚠️  未找到迁移定义: v${record.version}`);
        continue;
      }

      console.log(`🔄 回滚迁移: ${migration.name} (v${migration.version})`);

      const transaction = this.db.transaction(() => {
        migration.down(this.db!);
        
        this.db!.prepare('DELETE FROM migrations WHERE version = ?')
          .run(migration.version);
      });

      transaction();

      console.log(`✅ 回滚完成: ${migration.name}`);
    }
  }

  /**
   * 获取数据库实例（用于高级操作）
   */
  getDatabase(): Database.Database {
    if (!this.db) {
      throw new Error('数据库未连接');
    }
    return this.db;
  }

  /**
   * 执行原始SQL查询
   */
  query<T = any>(sql: string, params?: any[]): T[] {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    const stmt = this.db.prepare(sql);
    return params ? stmt.all(...params) as T[] : stmt.all() as T[];
  }

  /**
   * 在事务中执行操作
   */
  transaction<T>(fn: () => T): T {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    const transaction = this.db.transaction(fn);
    return transaction();
  }

  /**
   * 关闭数据库连接
   */
  close(): void {
    if (this.db) {
      this.db.close();
      this.db = null;
      console.log('✅ 数据库连接已关闭');
    }
  }

  /**
   * 备份数据库
   */
  backup(destPath: string): void {
    if (!this.db || this.config.memory) {
      throw new Error('无法备份内存数据库');
    }

    const destDir = path.dirname(destPath);
    if (!fs.existsSync(destDir)) {
      fs.mkdirSync(destDir, { recursive: true });
    }

    this.db.backup(destPath);
    console.log(`✅ 数据库已备份到: ${destPath}`);
  }

  /**
   * 获取数据库统计信息
   */
  getStats(): {
    users: number;
    organizations: number;
    subscriptions: number;
    usageRecords: number;
  } {
    if (!this.db) {
      throw new Error('数据库未连接');
    }

    const getUserCount = this.db.prepare('SELECT COUNT(*) as count FROM users');
    const getOrgCount = this.db.prepare('SELECT COUNT(*) as count FROM organizations');
    const getSubCount = this.db.prepare('SELECT COUNT(*) as count FROM subscriptions');
    const getUsageCount = this.db.prepare('SELECT COUNT(*) as count FROM usage_stats');

    return {
      users: (getUserCount.get() as any).count,
      organizations: (getOrgCount.get() as any).count,
      subscriptions: (getSubCount.get() as any).count,
      usageRecords: (getUsageCount.get() as any).count,
    };
  }
}

/**
 * 创建数据库管理器实例
 */
export function createDatabaseManager(config: DatabaseConfig): DatabaseManager {
  const manager = new DatabaseManager(config);
  manager.connect();
  manager.initialize();
  return manager;
}
