// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 创建模板验证CLI命令

import { Command } from 'commander';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';
import { TemplateValidator } from '../src/validator.js';

/**
 * 验证模板文件命令
 */
export async function validateTemplateCommand(filePath: string, options: any = {}) {
  console.log(chalk.cyan.bold('\n🔍 验证模板文件\n'));
  console.log(chalk.gray('─'.repeat(60)));

  try {
    // 读取模板文件
    const absolutePath = path.isAbsolute(filePath) 
      ? filePath 
      : path.join(process.cwd(), filePath);
    
    console.log(chalk.gray(`\n📄 模板文件: ${absolutePath}\n`));
    
    const templateContent = await fs.readFile(absolutePath, 'utf-8');
    const templateData = JSON.parse(templateContent);
    
    // 创建验证器
    const validator = new TemplateValidator();
    
    // 执行验证
    const result = options.fix 
      ? await validator.validateAndFix(templateData)
      : await validator.validate(templateData);
    
    // 打印结果
    validator.printValidationResult(result);
    
    // 如果自动修复成功，保存修复后的文件
    if (result.fixed && result.fixedTemplate && options.fix) {
      if (options.output) {
        // 保存到指定文件
        await fs.writeFile(
          options.output,
          JSON.stringify(result.fixedTemplate, null, 2),
          'utf-8'
        );
        console.log(chalk.green(`\n✅ 修复后的模板已保存到: ${options.output}`));
      } else if (options.inPlace) {
        // 原地修改
        await fs.writeFile(
          absolutePath,
          JSON.stringify(result.fixedTemplate, null, 2),
          'utf-8'
        );
        console.log(chalk.green(`\n✅ 模板已原地修复`));
      } else {
        // 显示修复后的内容
        console.log(chalk.cyan('\n📝 修复后的模板内容:'));
        console.log(chalk.gray('─'.repeat(60)));
        console.log(JSON.stringify(result.fixedTemplate, null, 2));
      }
    }
    
    console.log(chalk.gray('\n' + '─'.repeat(60)));
    
    // 提供下一步建议
    if (!result.valid && !options.fix) {
      console.log(chalk.yellow('\n💡 提示:'));
      console.log(chalk.white('  • 运行 ' + chalk.cyan('validate-template --fix') + ' 自动修复错误'));
      console.log(chalk.white('  • 运行 ' + chalk.cyan('validate-template --fix --in-place') + ' 原地修复'));
      console.log(chalk.white('  • 运行 ' + chalk.cyan('validate-template --fix --output <file>') + ' 保存到新文件'));
    }
    
    console.log('');
    
    // 返回结果码
    process.exit(result.valid ? 0 : 1);
    
  } catch (error: any) {
    console.log(chalk.gray('\n' + '─'.repeat(60)));
    console.error(chalk.red.bold('\n❌ 验证失败\n'));
    
    if (error.code === 'ENOENT') {
      console.error(chalk.red('文件不存在: ' + filePath));
    } else if (error instanceof SyntaxError) {
      console.error(chalk.red('JSON格式错误: ' + error.message));
    } else {
      console.error(chalk.red('错误详情: ' + error.message));
    }
    
    console.log('');
    process.exit(1);
  }
}

/**
 * 批量验证模板目录
 */
export async function validateTemplatesDir(dirPath: string, options: any = {}) {
  console.log(chalk.cyan.bold('\n🔍 批量验证模板\n'));
  console.log(chalk.gray('─'.repeat(60)));

  try {
    const absolutePath = path.isAbsolute(dirPath) 
      ? dirPath 
      : path.join(process.cwd(), dirPath);
    
    console.log(chalk.gray(`\n📁 模板目录: ${absolutePath}\n`));
    
    // 读取目录中的所有JSON文件
    const files = await fs.readdir(absolutePath);
    const jsonFiles = files.filter(f => f.endsWith('.json'));
    
    if (jsonFiles.length === 0) {
      console.log(chalk.yellow('⚠️  未找到模板文件'));
      process.exit(0);
    }
    
    console.log(chalk.white(`找到 ${jsonFiles.length} 个模板文件\n`));
    
    // 验证每个文件
    const validator = new TemplateValidator();
    const results: Array<{ file: string; valid: boolean; errors: number; warnings: number }> = [];
    
    for (const file of jsonFiles) {
      const filePath = path.join(absolutePath, file);
      const templateContent = await fs.readFile(filePath, 'utf-8');
      const templateData = JSON.parse(templateContent);
      
      const result = await validator.validate(templateData);
      
      results.push({
        file,
        valid: result.valid,
        errors: result.errors.filter(e => e.severity === 'error').length,
        warnings: result.warnings.length
      });
      
      // 打印简要结果
      const status = result.valid ? chalk.green('✓') : chalk.red('✗');
      const details = result.valid 
        ? chalk.gray(`(${result.warnings.length} warnings)`)
        : chalk.red(`(${result.errors.filter(e => e.severity === 'error').length} errors)`);
      
      console.log(`${status} ${file} ${details}`);
    }
    
    // 打印总结
    console.log(chalk.gray('\n' + '─'.repeat(60)));
    const validCount = results.filter(r => r.valid).length;
    const invalidCount = results.length - validCount;
    
    console.log(chalk.cyan('\n📊 验证总结:\n'));
    console.log(chalk.white(`  总计:   ${results.length} 个模板`));
    console.log(chalk.green(`  通过:   ${validCount} 个`));
    
    if (invalidCount > 0) {
      console.log(chalk.red(`  失败:   ${invalidCount} 个`));
    }
    
    console.log('');
    
    process.exit(invalidCount > 0 ? 1 : 0);
    
  } catch (error: any) {
    console.log(chalk.gray('\n' + '─'.repeat(60)));
    console.error(chalk.red.bold('\n❌ 验证失败\n'));
    console.error(chalk.red('错误详情: ' + error.message));
    console.log('');
    process.exit(1);
  }
}

// 如果直接运行此文件
if (import.meta.url === `file://${process.argv[1]}`) {
  const program = new Command();
  
  program
    .name('validate-template')
    .description('验证模板文件是否符合Schema定义')
    .argument('<file>', '模板文件路径')
    .option('--fix', '自动修复错误')
    .option('--in-place', '原地修改文件')
    .option('--output <file>', '保存修复后的文件到指定路径')
    .action(validateTemplateCommand);
  
  program
    .command('dir')
    .description('批量验证目录中的所有模板')
    .argument('<directory>', '模板目录路径')
    .action(validateTemplatesDir);
  
  program.parse();
}
