// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-15
// Task: M6 Phase2 - 实现敏感数据加密存储功能

import crypto from 'crypto';

/**
 * 加密算法配置
 */
const ENCRYPTION_CONFIG = {
  algorithm: 'aes-256-gcm',
  keyLength: 32,
  ivLength: 16,
  saltLength: 64,
  tagLength: 16,
  iterations: 100000,
  digest: 'sha512'
};

/**
 * 加密结果
 */
export interface EncryptedData {
  encrypted: string;      // Base64编码的加密数据
  iv: string;             // 初始化向量
  tag: string;            // 认证标签
  salt?: string;          // 盐值（用于密钥派生）
}

/**
 * 数据加密管理器
 */
export class DataEncryption {
  private masterKey: Buffer;

  constructor(masterKey: string | Buffer) {
    if (typeof masterKey === 'string') {
      // 确保密钥长度正确
      this.masterKey = crypto.scryptSync(
        masterKey,
        'meteor-shower-salt',
        ENCRYPTION_CONFIG.keyLength
      );
    } else {
      this.masterKey = masterKey;
    }
  }

  /**
   * 加密数据
   */
  encrypt(data: string): EncryptedData {
    try {
      // 生成随机IV
      const iv = crypto.randomBytes(ENCRYPTION_CONFIG.ivLength);

      // 创建加密器
      const cipher = crypto.createCipheriv(
        ENCRYPTION_CONFIG.algorithm,
        this.masterKey,
        iv
      );

      // 加密数据
      let encrypted = cipher.update(data, 'utf8', 'base64');
      encrypted += cipher.final('base64');

      // 获取认证标签
      const tag = (cipher as any).getAuthTag();

      return {
        encrypted,
        iv: iv.toString('base64'),
        tag: tag.toString('base64')
      };
    } catch (error) {
      throw new Error(`Encryption failed: ${(error as Error).message}`);
    }
  }

  /**
   * 解密数据
   */
  decrypt(encryptedData: EncryptedData): string {
    try {
      // 从Base64解码
      const iv = Buffer.from(encryptedData.iv, 'base64');
      const tag = Buffer.from(encryptedData.tag, 'base64');

      // 创建解密器
      const decipher = crypto.createDecipheriv(
        ENCRYPTION_CONFIG.algorithm,
        this.masterKey,
        iv
      );

      // 设置认证标签
      (decipher as any).setAuthTag(tag);

      // 解密数据
      let decrypted = decipher.update(encryptedData.encrypted, 'base64', 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;
    } catch (error) {
      throw new Error(`Decryption failed: ${(error as Error).message}`);
    }
  }

  /**
   * 加密JSON对象
   */
  encryptJSON(obj: any): EncryptedData {
    const json = JSON.stringify(obj);
    return this.encrypt(json);
  }

  /**
   * 解密JSON对象
   */
  decryptJSON<T = any>(encryptedData: EncryptedData): T {
    const json = this.decrypt(encryptedData);
    return JSON.parse(json);
  }

  /**
   * 批量加密字段
   */
  encryptFields<T extends Record<string, any>>(
    obj: T,
    fields: (keyof T)[]
  ): T & { __encrypted__: Record<string, EncryptedData> } {
    const result: any = { ...obj };
    const encrypted: Record<string, EncryptedData> = {};

    fields.forEach(field => {
      if (obj[field] !== undefined && obj[field] !== null) {
        const value = typeof obj[field] === 'string' 
          ? obj[field] 
          : JSON.stringify(obj[field]);
        
        encrypted[field as string] = this.encrypt(value);
        delete result[field];
      }
    });

    result.__encrypted__ = encrypted;
    return result;
  }

  /**
   * 批量解密字段
   */
  decryptFields<T extends Record<string, any>>(
    obj: T & { __encrypted__?: Record<string, EncryptedData> },
    fields: string[]
  ): T {
    const result: any = { ...obj };
    
    if (obj.__encrypted__) {
      fields.forEach(field => {
        if (obj.__encrypted__![field]) {
          const decrypted = this.decrypt(obj.__encrypted__![field]);
          
          // 尝试解析JSON
          try {
            result[field] = JSON.parse(decrypted);
          } catch {
            result[field] = decrypted;
          }
        }
      });

      delete result.__encrypted__;
    }

    return result;
  }

  /**
   * 生成数据哈希（用于验证完整性）
   */
  static hash(data: string): string {
    return crypto
      .createHash('sha256')
      .update(data)
      .digest('hex');
  }

  /**
   * 生成安全的随机token
   */
  static generateToken(length: number = 32): string {
    return crypto.randomBytes(length).toString('hex');
  }

  /**
   * 派生密钥（用于从密码生成加密密钥）
   */
  static deriveKey(
    password: string,
    salt?: string
  ): { key: Buffer; salt: string } {
    const actualSalt = salt || crypto.randomBytes(ENCRYPTION_CONFIG.saltLength).toString('hex');
    
    const key = crypto.scryptSync(
      password,
      actualSalt,
      ENCRYPTION_CONFIG.keyLength
    );

    return { key, salt: actualSalt };
  }
}

/**
 * 敏感字段管理器
 * 用于标记和处理敏感数据
 */
export class SensitiveFieldManager {
  private static SENSITIVE_PATTERNS = [
    /password/i,
    /secret/i,
    /token/i,
    /api[_-]?key/i,
    /private[_-]?key/i,
    /credit[_-]?card/i,
    /ssn/i,
    /social[_-]?security/i
  ];

  /**
   * 检测字段是否为敏感字段
   */
  static isSensitiveField(fieldName: string): boolean {
    return this.SENSITIVE_PATTERNS.some(pattern => pattern.test(fieldName));
  }

  /**
   * 自动检测并加密对象中的敏感字段
   */
  static autoEncryptSensitiveFields<T extends Record<string, any>>(
    obj: T,
    encryption: DataEncryption
  ): T & { __encrypted__: Record<string, EncryptedData> } {
    const sensitiveFields = Object.keys(obj).filter(key => 
      this.isSensitiveField(key)
    );

    return encryption.encryptFields(obj, sensitiveFields);
  }

  /**
   * 自动解密对象中的敏感字段
   */
  static autoDecryptSensitiveFields<T extends Record<string, any>>(
    obj: T & { __encrypted__?: Record<string, EncryptedData> },
    encryption: DataEncryption
  ): T {
    if (!obj.__encrypted__) {
      return obj;
    }

    const encryptedFields = Object.keys(obj.__encrypted__);
    return encryption.decryptFields(obj, encryptedFields);
  }

  /**
   * 脱敏显示（用于日志和UI）
   */
  static maskSensitiveData(value: string, maskChar: string = '*', showLength: number = 4): string {
    if (!value || value.length <= showLength * 2) {
      return maskChar.repeat(8);
    }

    const start = value.substring(0, showLength);
    const end = value.substring(value.length - showLength);
    const masked = maskChar.repeat(value.length - showLength * 2);

    return `${start}${masked}${end}`;
  }
}

/**
 * 密钥轮换管理器
 */
export class KeyRotationManager {
  private oldKey: DataEncryption;
  private newKey: DataEncryption;

  constructor(oldMasterKey: string | Buffer, newMasterKey: string | Buffer) {
    this.oldKey = new DataEncryption(oldMasterKey);
    this.newKey = new DataEncryption(newMasterKey);
  }

  /**
   * 重新加密数据（密钥轮换）
   */
  rotateEncryptedData(oldEncrypted: EncryptedData): EncryptedData {
    // 用旧密钥解密
    const decrypted = this.oldKey.decrypt(oldEncrypted);
    
    // 用新密钥加密
    return this.newKey.encrypt(decrypted);
  }

  /**
   * 批量轮换
   */
  rotateBatch(encryptedDataList: EncryptedData[]): EncryptedData[] {
    return encryptedDataList.map(data => this.rotateEncryptedData(data));
  }
}

/**
 * 加密存储包装器
 * 提供透明的加密/解密存储
 */
export class EncryptedStorage<T extends Record<string, any>> {
  private encryption: DataEncryption;
  private sensitiveFields: (keyof T)[];

  constructor(masterKey: string | Buffer, sensitiveFields: (keyof T)[]) {
    this.encryption = new DataEncryption(masterKey);
    this.sensitiveFields = sensitiveFields;
  }

  /**
   * 存储前加密
   */
  beforeStore(data: T): T & { __encrypted__: Record<string, EncryptedData> } {
    return this.encryption.encryptFields(data, this.sensitiveFields);
  }

  /**
   * 读取后解密
   */
  afterRetrieve(data: T & { __encrypted__?: Record<string, EncryptedData> }): T {
    return this.encryption.decryptFields(data, this.sensitiveFields as string[]);
  }

  /**
   * 安全存储（返回可持久化的对象）
   */
  secureStore(data: T): string {
    const encrypted = this.beforeStore(data);
    return JSON.stringify(encrypted);
  }

  /**
   * 安全读取（从持久化数据恢复）
   */
  secureRetrieve(storedData: string): T {
    const parsed = JSON.parse(storedData);
    return this.afterRetrieve(parsed);
  }
}
