// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: å®ç°Cloud Hubæ–‡ä»¶ç³»ç»ŸæŒä¹…åŒ–

import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';

/**
 * æ¨¡æ¿æ•°æ®ç»“æ„
 */
export interface Template {
  id: string;
  name: string;
  version: string;
  description?: string;
  author?: string;
  targets: string[];
  variables: Record<string, any>;
  configs?: any[];
  tags?: string[];
  createdAt: string;
  updatedAt?: string;
  downloads?: number;
  rating?: number;
}

/**
 * å­˜å‚¨é…ç½®
 */
export interface StorageConfig {
  dataDir: string;           // æ•°æ®å­˜å‚¨ç›®å½•
  templatesFile: string;     // æ¨¡æ¿ç´¢å¼•æ–‡ä»¶
  templatesDataDir: string;  // æ¨¡æ¿è¯¦ç»†æ•°æ®ç›®å½•
}

/**
 * æ–‡ä»¶ç³»ç»Ÿå­˜å‚¨ç±»
 * æä¾›åŸºäºæ–‡ä»¶ç³»ç»Ÿçš„æŒä¹…åŒ–å­˜å‚¨åŠŸèƒ½
 */
export class FileStorage {
  private config: StorageConfig;
  private templates: Map<string, Template> = new Map();
  private initialized: boolean = false;

  constructor(dataDir: string = '.meteor-cloud-data') {
    this.config = {
      dataDir: path.resolve(dataDir),
      templatesFile: path.resolve(dataDir, 'templates-index.json'),
      templatesDataDir: path.resolve(dataDir, 'templates')
    };
  }

  /**
   * åˆå§‹åŒ–å­˜å‚¨
   * åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„å¹¶åŠ è½½ç°æœ‰æ•°æ®
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    try {
      // åˆ›å»ºç›®å½•ç»“æ„
      await fs.mkdir(this.config.dataDir, { recursive: true });
      await fs.mkdir(this.config.templatesDataDir, { recursive: true });

      // åŠ è½½ç°æœ‰æ¨¡æ¿ç´¢å¼•
      await this.loadTemplatesIndex();

      this.initialized = true;
      console.log(chalk.green('âœ… æ–‡ä»¶å­˜å‚¨åˆå§‹åŒ–æˆåŠŸ'));
      console.log(chalk.gray(`  æ•°æ®ç›®å½•: ${this.config.dataDir}`));
      console.log(chalk.gray(`  å·²åŠ è½½æ¨¡æ¿: ${this.templates.size} ä¸ª`));
    } catch (error: any) {
      console.error(chalk.red('âŒ å­˜å‚¨åˆå§‹åŒ–å¤±è´¥:'), error.message);
      throw error;
    }
  }

  /**
   * åŠ è½½æ¨¡æ¿ç´¢å¼•
   */
  private async loadTemplatesIndex(): Promise<void> {
    try {
      const indexContent = await fs.readFile(this.config.templatesFile, 'utf-8');
      const templatesArray: Template[] = JSON.parse(indexContent);
      
      this.templates.clear();
      templatesArray.forEach(template => {
        this.templates.set(template.id, template);
      });
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ›å»ºç©ºç´¢å¼•
        await this.saveTemplatesIndex();
      } else {
        throw error;
      }
    }
  }

  /**
   * ä¿å­˜æ¨¡æ¿ç´¢å¼•
   */
  private async saveTemplatesIndex(): Promise<void> {
    const templatesArray = Array.from(this.templates.values());
    await fs.writeFile(
      this.config.templatesFile,
      JSON.stringify(templatesArray, null, 2),
      'utf-8'
    );
  }

  /**
   * ä¿å­˜æ¨¡æ¿
   * @param template æ¨¡æ¿å¯¹è±¡
   */
  async saveTemplate(template: Template): Promise<Template> {
    this.ensureInitialized();

    const now = new Date().toISOString();
    const existingTemplate = this.templates.get(template.id);

    const savedTemplate: Template = {
      ...template,
      createdAt: existingTemplate?.createdAt || now,
      updatedAt: now,
      downloads: existingTemplate?.downloads || 0,
      rating: existingTemplate?.rating || 0
    };

    // ä¿å­˜åˆ°å†…å­˜ç´¢å¼•
    this.templates.set(template.id, savedTemplate);

    // ä¿å­˜æ¨¡æ¿è¯¦ç»†æ•°æ®åˆ°å•ç‹¬æ–‡ä»¶
    const templateFilePath = path.join(
      this.config.templatesDataDir,
      `${template.id}.json`
    );
    await fs.writeFile(
      templateFilePath,
      JSON.stringify(savedTemplate, null, 2),
      'utf-8'
    );

    // æ›´æ–°ç´¢å¼•æ–‡ä»¶
    await this.saveTemplatesIndex();

    console.log(chalk.gray(`  ğŸ’¾ æ¨¡æ¿å·²ä¿å­˜: ${template.id}`));
    return savedTemplate;
  }

  /**
   * è·å–æ¨¡æ¿
   * @param id æ¨¡æ¿ID
   */
  async getTemplate(id: string): Promise<Template | null> {
    this.ensureInitialized();

    const template = this.templates.get(id);
    if (!template) {
      return null;
    }

    // ä»æ–‡ä»¶åŠ è½½å®Œæ•´æ•°æ®
    try {
      const templateFilePath = path.join(
        this.config.templatesDataDir,
        `${id}.json`
      );
      const content = await fs.readFile(templateFilePath, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      console.warn(chalk.yellow(`âš ï¸  æ— æ³•åŠ è½½æ¨¡æ¿æ–‡ä»¶: ${id}`));
      return template; // è¿”å›ç´¢å¼•ä¸­çš„åŸºæœ¬ä¿¡æ¯
    }
  }

  /**
   * è·å–æ‰€æœ‰æ¨¡æ¿
   * @param filter è¿‡æ»¤æ¡ä»¶
   */
  async listTemplates(filter?: {
    tool?: string;
    tags?: string[];
    author?: string;
    search?: string;
  }): Promise<Template[]> {
    this.ensureInitialized();

    let templates = Array.from(this.templates.values());

    if (filter) {
      // æŒ‰å·¥å…·è¿‡æ»¤
      if (filter.tool) {
        templates = templates.filter(t => 
          t.targets.includes(filter.tool!)
        );
      }

      // æŒ‰æ ‡ç­¾è¿‡æ»¤
      if (filter.tags && filter.tags.length > 0) {
        templates = templates.filter(t => 
          t.tags && filter.tags!.some(tag => t.tags!.includes(tag))
        );
      }

      // æŒ‰ä½œè€…è¿‡æ»¤
      if (filter.author) {
        templates = templates.filter(t => 
          t.author === filter.author
        );
      }

      // æŒ‰å…³é”®è¯æœç´¢
      if (filter.search) {
        const searchLower = filter.search.toLowerCase();
        templates = templates.filter(t => 
          t.name.toLowerCase().includes(searchLower) ||
          (t.description && t.description.toLowerCase().includes(searchLower))
        );
      }
    }

    return templates;
  }

  /**
   * åˆ é™¤æ¨¡æ¿
   * @param id æ¨¡æ¿ID
   */
  async deleteTemplate(id: string): Promise<boolean> {
    this.ensureInitialized();

    if (!this.templates.has(id)) {
      return false;
    }

    // ä»å†…å­˜åˆ é™¤
    this.templates.delete(id);

    // åˆ é™¤æ–‡ä»¶
    const templateFilePath = path.join(
      this.config.templatesDataDir,
      `${id}.json`
    );
    try {
      await fs.unlink(templateFilePath);
    } catch (error) {
      console.warn(chalk.yellow(`âš ï¸  æ— æ³•åˆ é™¤æ¨¡æ¿æ–‡ä»¶: ${id}`));
    }

    // æ›´æ–°ç´¢å¼•
    await this.saveTemplatesIndex();

    console.log(chalk.gray(`  ğŸ—‘ï¸  æ¨¡æ¿å·²åˆ é™¤: ${id}`));
    return true;
  }

  /**
   * å¢åŠ ä¸‹è½½è®¡æ•°
   * @param id æ¨¡æ¿ID
   */
  async incrementDownloads(id: string): Promise<void> {
    this.ensureInitialized();

    const template = this.templates.get(id);
    if (template) {
      template.downloads = (template.downloads || 0) + 1;
      template.updatedAt = new Date().toISOString();
      await this.saveTemplate(template);
    }
  }

  /**
   * æ›´æ–°è¯„åˆ†
   * @param id æ¨¡æ¿ID
   * @param rating è¯„åˆ† (0-5)
   */
  async updateRating(id: string, rating: number): Promise<void> {
    this.ensureInitialized();

    if (rating < 0 || rating > 5) {
      throw new Error('è¯„åˆ†å¿…é¡»åœ¨ 0-5 ä¹‹é—´');
    }

    const template = this.templates.get(id);
    if (template) {
      template.rating = rating;
      template.updatedAt = new Date().toISOString();
      await this.saveTemplate(template);
    }
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  async getStats(): Promise<{
    totalTemplates: number;
    totalDownloads: number;
    averageRating: number;
    toolsCount: Record<string, number>;
  }> {
    this.ensureInitialized();

    const templates = Array.from(this.templates.values());
    const totalDownloads = templates.reduce((sum, t) => sum + (t.downloads || 0), 0);
    const ratedTemplates = templates.filter(t => t.rating !== undefined);
    const averageRating = ratedTemplates.length > 0
      ? ratedTemplates.reduce((sum, t) => sum + (t.rating || 0), 0) / ratedTemplates.length
      : 0;

    // ç»Ÿè®¡å„å·¥å…·çš„æ¨¡æ¿æ•°é‡
    const toolsCount: Record<string, number> = {};
    templates.forEach(template => {
      template.targets.forEach(tool => {
        toolsCount[tool] = (toolsCount[tool] || 0) + 1;
      });
    });

    return {
      totalTemplates: templates.length,
      totalDownloads,
      averageRating,
      toolsCount
    };
  }

  /**
   * æ¸…ç©ºæ‰€æœ‰æ•°æ®ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
   */
  async clearAll(): Promise<void> {
    this.ensureInitialized();

    this.templates.clear();
    await this.saveTemplatesIndex();

    // åˆ é™¤æ‰€æœ‰æ¨¡æ¿æ–‡ä»¶
    const files = await fs.readdir(this.config.templatesDataDir);
    for (const file of files) {
      if (file.endsWith('.json')) {
        await fs.unlink(path.join(this.config.templatesDataDir, file));
      }
    }

    console.log(chalk.yellow('âš ï¸  æ‰€æœ‰æ•°æ®å·²æ¸…ç©º'));
  }

  /**
   * ç¡®ä¿å­˜å‚¨å·²åˆå§‹åŒ–
   */
  private ensureInitialized(): void {
    if (!this.initialized) {
      throw new Error('å­˜å‚¨æœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè°ƒç”¨ initialize()');
    }
  }

  /**
   * å¯¼å‡ºæ‰€æœ‰æ•°æ®
   * @param exportPath å¯¼å‡ºæ–‡ä»¶è·¯å¾„
   */
  async exportData(exportPath: string): Promise<void> {
    this.ensureInitialized();

    const templates = Array.from(this.templates.values());
    const exportData = {
      version: '1.0.0',
      exportedAt: new Date().toISOString(),
      templates
    };

    await fs.writeFile(
      exportPath,
      JSON.stringify(exportData, null, 2),
      'utf-8'
    );

    console.log(chalk.green(`âœ… æ•°æ®å·²å¯¼å‡ºåˆ°: ${exportPath}`));
  }

  /**
   * å¯¼å…¥æ•°æ®
   * @param importPath å¯¼å…¥æ–‡ä»¶è·¯å¾„
   */
  async importData(importPath: string): Promise<void> {
    this.ensureInitialized();

    const content = await fs.readFile(importPath, 'utf-8');
    const importData = JSON.parse(content);

    if (!importData.templates || !Array.isArray(importData.templates)) {
      throw new Error('å¯¼å…¥æ–‡ä»¶æ ¼å¼æ— æ•ˆ');
    }

    for (const template of importData.templates) {
      await this.saveTemplate(template);
    }

    console.log(chalk.green(`âœ… å·²å¯¼å…¥ ${importData.templates.length} ä¸ªæ¨¡æ¿`));
  }
}

