// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 实现Gemini适配器完整文件写入逻辑（参考Claude/Cursor模式）

/**
 * Gemini 适配器实现
 * 负责 Google Gemini AI 模型的配置文件管理
 *
 * 核心功能：
 * - 生成 Gemini 主配置文件 (GEMINI.md)
 * - 生成设置文件 (settings.json)
 * - 生成命令规划文件 (plan.toml)
 * - 支持文件备份和回滚
 *
 * 文件位置：
 * - ~/.gemini/GEMINI.md - 全局主配置
 * - ~/.gemini/settings.json - API 设置
 * - .gemini/commands/plan.toml - 项目命令配置
 */

import { Adapter, ApplyContext, DiffResult } from './index.js';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

/**
 * Gemini 适配器类
 * 实现 Adapter 接口，提供 Gemini 配置的完整生命周期管理
 */
export class GeminiAdapter implements Adapter {
  // 备份文件路径映射：原始路径 -> 备份路径
  private backupPaths: Map<string, string> = new Map();

  /**
   * 规划配置变更
   * 分析将要创建或修改的配置文件，不实际修改
   *
   * @param ctx 应用上下文，包含变量和配置
   * @returns 差异结果，包含变更列表和摘要
   */
  async plan(ctx: ApplyContext): Promise<DiffResult> {
    console.log(chalk.gray('📋 规划 Gemini 配置变更...'));
    
    return {
      changes: [
        { path: '~/.gemini/GEMINI.md', kind: 'create' },
        { path: '~/.gemini/settings.json', kind: 'create' },
        { path: './.gemini/commands/plan.toml', kind: 'create' }
      ],
      summary: '将创建 3 个 Gemini 配置文件'
    };
  }

  /**
   * 应用配置变更
   * 实际写入 Gemini 配置文件到文件系统
   *
   * 工作流程：
   * 1. 检查是否为 dryRun 模式
   * 2. 调用 writeGeminiConfigs 写入文件
   *
   * @param ctx 应用上下文
   */
  async apply(ctx: ApplyContext): Promise<void> {
    console.log(chalk.green('⚡ 应用 Gemini 配置...'));
    
    if (ctx.dryRun) {
      console.log(chalk.yellow('🔍 模拟模式：跳过实际写入'));
      return;
    }
    
    await this.writeGeminiConfigs(ctx);
  }

  /**
   * 回滚配置变更
   * 从备份文件恢复原始配置，用于错误恢复
   *
   * 回滚逻辑：
   * 1. 遍历所有备份文件
   * 2. 将备份内容恢复到原始位置
   * 3. 清空备份记录
   *
   * @param ctx 应用上下文
   */
  async rollback(ctx: ApplyContext): Promise<void> {
    console.log(chalk.yellow('🔄 回滚 Gemini 配置...'));
    
    for (const [originalPath, backupPath] of this.backupPaths) {
      try {
        const content = await fs.readFile(backupPath, 'utf-8');
        await fs.writeFile(originalPath, content, 'utf-8');
        console.log(chalk.yellow(`  🔄 回滚: ${originalPath}`));
      } catch (error) {
        console.error(chalk.red(`  ❌ 回滚失败 ${originalPath}: ${error}`));
      }
    }
    
    this.backupPaths.clear();
    console.log(chalk.green('✅ Gemini 配置回滚完成'));
  }

  /**
   * 写入 Gemini 配置文件
   * 核心文件写入逻辑，处理备份、目录创建和文件写入
   *
   * 工作流程：
   * 1. 定义需要写入的配置文件列表
   * 2. 对每个文件：
   *    a. 备份现有文件（如果存在）
   *    b. 创建目录（如果不存在）
   *    c. 写入新配置内容
   * 3. 记录备份路径，用于回滚
   *
   * @param ctx 应用上下文
   */
  private async writeGeminiConfigs(ctx: ApplyContext): Promise<void> {
    const homeDir = os.homedir();
    const projectRoot = process.cwd();
    
    // 定义需要生成的三个配置文件
    const configs = [
      {
        target: path.join(homeDir, '.gemini', 'GEMINI.md'),
        content: this.generateGeminiMd(ctx.variables),
        description: 'Gemini 主配置文件'
      },
      {
        target: path.join(homeDir, '.gemini', 'settings.json'),
        content: this.generateSettingsJson(ctx.variables),
        description: 'Gemini 设置文件'
      },
      {
        target: path.join(projectRoot, '.gemini', 'commands', 'plan.toml'),
        content: this.generatePlanToml(ctx.variables),
        description: 'Gemini 命令规划文件'
      }
    ];

    // 依次处理每个配置文件
    for (const config of configs) {
      try {
        // ========== 备份现有文件 ==========
        // 如果文件存在，先进行备份以便回滚
        try {
          await fs.access(config.target);
          const backup = `${config.target}.backup`;
          await fs.copyFile(config.target, backup);
          this.backupPaths.set(config.target, backup);
        } catch {
          // 文件不存在，无需备份
        }

        // ========== 创建目录和写入文件 ==========
        // 确保父目录存在
        await fs.mkdir(path.dirname(config.target), { recursive: true });
        
        // 写入文件
        await fs.writeFile(config.target, config.content, 'utf-8');
        console.log(chalk.gray(`  ✅ 写入 ${config.description}: ${config.target}`));
      } catch (error) {
        console.error(chalk.red(`  ❌ 写入失败 ${config.description}: ${error}`));
        throw error;
      }
    }
  }

  /**
   * 生成 GEMINI.md 主配置文件
   * 包含角色定位、编码规范、开发流程等
   *
   * @param variables 配置变量
   * @returns Markdown 格式的配置内容
   */
  private generateGeminiMd(variables: Record<string, unknown>): string {
    const projectName = variables.projectName || 'my-project';
    const persona = variables.persona || '你是一名 AI 辅助开发专家';
    
    return `# ${projectName} - Gemini 配置

## 角色定位
${persona}

## 编码规范
- 使用 TypeScript
- 遵循 ESLint 规则
- 编写单元测试
- 保持代码可读性

## 开发流程
1. 分析需求和上下文
2. 设计技术方案
3. 实现核心逻辑
4. 编写测试用例
5. 代码审查优化

## Gemini 特性配置
- 多模态支持: ${variables.enableMultimodal ? '启用' : '禁用'}
- 代码生成优化: ${variables.enableCodeOptimization ? '启用' : '禁用'}
- 上下文窗口: ${variables.contextWindow || '32k tokens'}
`;
  }

  /**
   * 生成 settings.json 设置文件
   * 包含 API 密钥、模型参数、安全设置等
   *
   * @param variables 配置变量
   * @returns JSON 格式的设置内容
   */
  private generateSettingsJson(variables: Record<string, unknown>): string {
    return JSON.stringify({
      apiKey: "{{GEMINI_API_KEY}}",
      model: variables.geminiModel || "gemini-2.0-flash-exp",
      temperature: variables.temperature || 0.2,
      maxOutputTokens: variables.maxTokens || 8192,
      topP: variables.topP || 0.95,
      topK: variables.topK || 40,
      safetySettings: [
        {
          category: "HARM_CATEGORY_HARASSMENT",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        },
        {
          category: "HARM_CATEGORY_HATE_SPEECH",
          threshold: "BLOCK_MEDIUM_AND_ABOVE"
        }
      ],
      generationConfig: {
        stopSequences: variables.stopSequences || [],
        candidateCount: 1,
        responseMimeType: "text/plain"
      }
    }, null, 2);
  }

  /**
   * 生成 plan.toml 命令规划文件
   * 包含项目信息、命令配置、工佟流步骤等
   *
   * @param variables 配置变量
   * @returns TOML 格式的配置内容
   */
  private generatePlanToml(variables: Record<string, unknown>): string {
    const projectDescription = variables.projectDescription || '项目开发规划';
    
    return `# Gemini 命令规划配置

[project]
name = "${variables.projectName || 'my-project'}"
description = "${projectDescription}"

[commands.plan]
enabled = true
model = "${variables.geminiModel || 'gemini-2.0-flash-exp'}"
max_tokens = ${variables.maxTokens || 8192}

[commands.implement]
enabled = true
require_tests = ${variables.requireTests !== false}
code_style = "${variables.indentStyle || '2 spaces'}"

[commands.review]
enabled = true
auto_fix = ${variables.autoFix || false}
lint_on_save = ${variables.enableESLint || true}

[workflow]
steps = [
  "analyze",
  "plan",
  "implement",
  "test",
  "review"
]

[quality]
min_coverage = ${variables.minCoverage || 80}
enforce_types = ${variables.enforceTypes !== false}
require_docs = ${variables.requireDocs || false}
`;
  }
}
