// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 实现Cursor适配器完整逻辑

import { Adapter, ApplyContext, DiffResult } from './index.js';
import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';

export class CursorAdapter implements Adapter {
  private backupPaths: Map<string, string> = new Map();

  async plan(ctx: ApplyContext): Promise<DiffResult> {
    console.log(chalk.gray('📋 规划 Cursor 配置变更...'));
    
    return {
      changes: [
        { path: './.cursor/rules.txt', kind: 'create' },
        { path: './.cursorrules', kind: 'create' }
      ],
      summary: '将创建 Cursor 规则文件'
    };
  }

  async apply(ctx: ApplyContext): Promise<void> {
    console.log(chalk.green('⚡ 应用 Cursor 配置...'));
    
    if (ctx.dryRun) {
      console.log(chalk.yellow('🔍 模拟模式：跳过实际写入'));
      return;
    }
    
    await this.writeCursorConfigs(ctx);
  }

  async rollback(ctx: ApplyContext): Promise<void> {
    console.log(chalk.yellow('🔄 回滚 Cursor 配置...'));
    
    for (const [originalPath, backupPath] of this.backupPaths) {
      try {
        const content = await fs.readFile(backupPath, 'utf-8');
        await fs.writeFile(originalPath, content, 'utf-8');
        console.log(chalk.yellow(`  🔄 回滚: ${originalPath}`));
      } catch (error) {
        console.error(chalk.red(`  ❌ 回滚失败 ${originalPath}: ${error}`));
      }
    }
    
    this.backupPaths.clear();
    console.log(chalk.green('✅ Cursor 配置回滚完成'));
  }

  private async writeCursorConfigs(ctx: ApplyContext): Promise<void> {
    const projectRoot = process.cwd();
    
    const configs = [
      {
        target: path.join(projectRoot, '.cursor', 'rules.txt'),
        content: this.generateCursorRules(ctx.variables),
        description: 'Cursor 规则文件'
      },
      {
        target: path.join(projectRoot, '.cursorrules'),
        content: this.generateCursorRulesFile(ctx.variables),
        description: 'Cursor 根规则文件'
      }
    ];

    for (const config of configs) {
      try {
        // 备份现有文件
        try {
          await fs.access(config.target);
          const backup = `${config.target}.backup`;
          await fs.copyFile(config.target, backup);
          this.backupPaths.set(config.target, backup);
        } catch {
          // 文件不存在，无需备份
        }

        // 确保目录存在
        await fs.mkdir(path.dirname(config.target), { recursive: true });
        
        // 写入文件
        await fs.writeFile(config.target, config.content, 'utf-8');
        console.log(chalk.gray(`  ✅ 写入 ${config.description}: ${config.target}`));
      } catch (error) {
        console.error(chalk.red(`  ❌ 写入失败 ${config.description}: ${error}`));
        throw error;
      }
    }
  }

  private generateCursorRules(variables: Record<string, unknown>): string {
    const projectName = variables.projectName || 'my-project';
    const persona = variables.persona || '你是一名资深架构师';
    
    return `# ${projectName} - Cursor 规则

${persona}

## 代码风格
- 使用现代 JavaScript/TypeScript
- 遵循项目 ESLint 配置
- 编写清晰的注释
- 保持函数单一职责

## 测试要求
- 每个新功能必须有测试
- 测试覆盖率 > 80%
- 使用适当的测试框架

## 开发规范
- 代码缩进: ${variables.indentStyle || '2 spaces'}
- Prettier: ${variables.enablePrettier ? '启用' : '禁用'}
- ESLint: ${variables.enableESLint ? '启用' : '禁用'}

## Cursor Composer 配置
- 启用: ${variables.enableComposer ? 'true' : 'false'}
- 模型: ${variables.cursorModel || 'gpt-4'}
`;
  }

  private generateCursorRulesFile(variables: Record<string, unknown>): string {
    const projectDescription = variables.projectDescription || '项目描述';
    const persona = variables.persona || '你是一名全栈工程师';
    
    return `${persona}

项目: ${projectDescription}

编码规范:
- 遵循项目现有代码风格
- 编写单元测试
- 添加必要的注释
- 保持代码简洁

响应要求:
- 提供清晰的解释
- 给出可执行的代码
- 考虑边界情况
- 注重性能和安全
`;
  }
}
