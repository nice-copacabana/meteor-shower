// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 为Gemini适配器补充完整单元测试

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { GeminiAdapter } from '../src/gemini.js';
import { ApplyContext } from '../src/index.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('GeminiAdapter', () => {
  let adapter: GeminiAdapter;
  let testDir: string;
  let homeDir: string;

  beforeEach(async () => {
    // 创建临时测试目录
    testDir = path.join(os.tmpdir(), `gemini-test-${Date.now()}`);
    homeDir = path.join(testDir, 'home');
    await fs.mkdir(homeDir, { recursive: true });
    await fs.mkdir(testDir, { recursive: true });

    // Mock os.homedir
    vi.spyOn(os, 'homedir').mockReturnValue(homeDir);
    
    // Mock process.cwd
    vi.spyOn(process, 'cwd').mockReturnValue(testDir);

    adapter = new GeminiAdapter();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('plan', () => {
    it('should return changes for new Gemini installation', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.changes).toBeDefined();
      expect(result.changes.length).toBeGreaterThan(0);
      expect(result.summary).toContain('Gemini');
    });

    it('should detect create operation when files do not exist', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.changes.every(c => c.kind === 'create')).toBe(true);
    });

    it('should include all expected config files in changes', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      const paths = result.changes.map(c => c.path);
      expect(paths.some(p => p.includes('GEMINI.md'))).toBe(true);
      expect(paths.some(p => p.includes('settings.json'))).toBe(true);
      expect(paths.some(p => p.includes('plan.toml'))).toBe(true);
    });

    it('should return correct file count in summary', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.summary).toMatch(/\d+ 个/);
      expect(result.changes.length).toBe(3);
    });
  });

  describe('apply', () => {
    it('should create all Gemini config files successfully', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'TestProject',
          persona: 'You are an AI assistant'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const geminiMdPath = path.join(homeDir, '.gemini', 'GEMINI.md');
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const planTomlPath = path.join(testDir, '.gemini', 'commands', 'plan.toml');

      expect(await fileExists(geminiMdPath)).toBe(true);
      expect(await fileExists(settingsJsonPath)).toBe(true);
      expect(await fileExists(planTomlPath)).toBe(true);
    });

    it('should skip file creation in dry run mode', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: true,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const geminiDir = path.join(homeDir, '.gemini');
      const dirExists = await fileExists(geminiDir);
      expect(dirExists).toBe(false);
    });

    it('should replace variables in generated GEMINI.md', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'MyAwesomeProject',
          persona: 'Expert AI assistant',
          enableMultimodal: true,
          contextWindow: '128k tokens'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const geminiMdPath = path.join(homeDir, '.gemini', 'GEMINI.md');
      const content = await fs.readFile(geminiMdPath, 'utf-8');
      
      expect(content).toContain('MyAwesomeProject');
      expect(content).toContain('Expert AI assistant');
      expect(content).toContain('启用');
      expect(content).toContain('128k tokens');
    });

    it('should generate valid JSON settings file', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          geminiModel: 'gemini-2.0-flash-exp',
          temperature: 0.3,
          maxTokens: 4096
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const content = await fs.readFile(settingsJsonPath, 'utf-8');
      
      // Should be valid JSON
      expect(() => JSON.parse(content)).not.toThrow();
      
      const config = JSON.parse(content);
      expect(config.model).toBe('gemini-2.0-flash-exp');
      expect(config.temperature).toBe(0.3);
      expect(config.maxOutputTokens).toBe(4096);
    });

    it('should generate valid TOML plan file', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'TOMLTest',
          requireTests: true,
          minCoverage: 85
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const planTomlPath = path.join(testDir, '.gemini', 'commands', 'plan.toml');
      const content = await fs.readFile(planTomlPath, 'utf-8');
      
      expect(content).toContain('[project]');
      expect(content).toContain('TOMLTest');
      expect(content).toContain('require_tests = true');
      expect(content).toContain('min_coverage = 85');
    });

    it('should create backup before updating existing file', async () => {
      // Arrange
      const geminiDir = path.join(homeDir, '.gemini');
      await fs.mkdir(geminiDir, { recursive: true });
      const originalContent = '{"old": "config"}';
      await fs.writeFile(path.join(geminiDir, 'settings.json'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert - 备份应该已创建
      const backupPath = path.join(geminiDir, 'settings.json.backup');
      const backupExists = await fileExists(backupPath);
      expect(backupExists).toBe(true);
    });

    it('should create directory structure if it does not exist', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const geminiHomeDir = path.join(homeDir, '.gemini');
      const geminiCommandsDir = path.join(testDir, '.gemini', 'commands');

      expect(await fileExists(geminiHomeDir)).toBe(true);
      expect(await fileExists(geminiCommandsDir)).toBe(true);
    });

    it('should use default values when variables are not provided', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const content = await fs.readFile(settingsJsonPath, 'utf-8');
      const config = JSON.parse(content);

      expect(config.model).toBe('gemini-2.0-flash-exp');
      expect(config.temperature).toBe(0.2);
      expect(config.maxOutputTokens).toBe(8192);
    });
  });

  describe('rollback', () => {
    it('should restore files from backup', async () => {
      // Arrange
      const geminiDir = path.join(homeDir, '.gemini');
      await fs.mkdir(geminiDir, { recursive: true });
      
      const originalContent = '{"version": "original"}';
      await fs.writeFile(path.join(geminiDir, 'settings.json'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // 应用配置（会创建备份）
      await adapter.apply(ctx);

      // 获取应用后的内容
      const appliedContent = await fs.readFile(path.join(geminiDir, 'settings.json'), 'utf-8');
      expect(appliedContent).not.toBe(originalContent);

      // Act - 回滚
      await adapter.rollback(ctx);

      // Assert - 文件应该恢复到应用时的备份状态
      const backupPath = path.join(geminiDir, 'settings.json.backup');
      const backupExists = await fileExists(backupPath);
      
      if (backupExists) {
        const backupContent = await fs.readFile(backupPath, 'utf-8');
        expect(backupContent).toBe(originalContent);
      }
    });

    it('should handle rollback when no backup exists', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act & Assert - 不应抛出错误
      await expect(adapter.rollback(ctx)).resolves.not.toThrow();
    });

    it('should clear backup paths after rollback', async () => {
      // Arrange
      const geminiDir = path.join(homeDir, '.gemini');
      await fs.mkdir(geminiDir, { recursive: true });
      await fs.writeFile(path.join(geminiDir, 'settings.json'), '{}', 'utf-8');

      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      // Act
      await adapter.rollback(ctx);

      // 再次回滚不应出错
      await expect(adapter.rollback(ctx)).resolves.not.toThrow();
    });
  });

  describe('Error handling', () => {
    it('should handle file write errors gracefully', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Mock fs.writeFile to throw error
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockRejectedValueOnce(new Error('Write error'));

      // Act & Assert
      await expect(adapter.apply(ctx)).rejects.toThrow();

      // Cleanup
      fs.writeFile = originalWriteFile;
    });

    it('should rollback on apply failure', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Mock to cause failure partway through
      let writeCount = 0;
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockImplementation(async (...args: any[]) => {
        writeCount++;
        if (writeCount > 2) {
          throw new Error('Simulated failure');
        }
        return originalWriteFile.apply(fs, args as any);
      });

      // Act
      try {
        await adapter.apply(ctx);
      } catch (error) {
        // Expected to fail
        expect(error).toBeDefined();
      }

      // Cleanup
      fs.writeFile = originalWriteFile;
    });

    it('should handle directory creation errors', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Mock fs.mkdir to fail
      const originalMkdir = fs.mkdir;
      vi.spyOn(fs, 'mkdir').mockRejectedValueOnce(new Error('Cannot create directory'));

      // Act & Assert
      await expect(adapter.apply(ctx)).rejects.toThrow();

      // Cleanup
      fs.mkdir = originalMkdir;
    });
  });

  describe('Integration scenarios', () => {
    it('should complete full workflow: plan -> apply -> rollback', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'FullWorkflow',
          persona: 'Integration test assistant'
        }
      };

      // Act 1: Plan
      const planResult = await adapter.plan(ctx);
      expect(planResult.changes.length).toBeGreaterThan(0);

      // Act 2: Apply
      await adapter.apply(ctx);
      
      const geminiMdPath = path.join(homeDir, '.gemini', 'GEMINI.md');
      const mdExists = await fileExists(geminiMdPath);
      expect(mdExists).toBe(true);

      // Act 3: Rollback
      await adapter.rollback(ctx);
      
      // Test completes without errors
    });

    it('should handle multiple apply calls idempotently', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'Idempotent'
        }
      };

      // Act - Apply multiple times
      await adapter.apply(ctx);
      await adapter.apply(ctx);
      await adapter.apply(ctx);

      // Assert - Files should still exist and be valid
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const content = await fs.readFile(settingsJsonPath, 'utf-8');
      expect(() => JSON.parse(content)).not.toThrow();
    });

    it('should create proper directory structure', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const homeGeminiDir = path.join(homeDir, '.gemini');
      const projectGeminiDir = path.join(testDir, '.gemini', 'commands');

      expect(await fileExists(homeGeminiDir)).toBe(true);
      expect(await fileExists(projectGeminiDir)).toBe(true);
    });
  });

  describe('Content generation', () => {
    it('should generate GEMINI.md with proper markdown structure', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'StructureTest',
          persona: 'Structure validator'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const geminiMdPath = path.join(homeDir, '.gemini', 'GEMINI.md');
      const content = await fs.readFile(geminiMdPath, 'utf-8');
      
      // Should contain markdown headers
      expect(content).toMatch(/^#/m);
      expect(content).toContain('StructureTest');
      expect(content).toContain('编码规范');
      expect(content).toContain('开发流程');
    });

    it('should include Gemini-specific features in settings', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const content = await fs.readFile(settingsJsonPath, 'utf-8');
      const config = JSON.parse(content);

      expect(config.safetySettings).toBeDefined();
      expect(config.generationConfig).toBeDefined();
      expect(config.topP).toBeDefined();
      expect(config.topK).toBeDefined();
    });

    it('should generate comprehensive plan.toml with all sections', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          projectName: 'ComprehensiveTest'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const planTomlPath = path.join(testDir, '.gemini', 'commands', 'plan.toml');
      const content = await fs.readFile(planTomlPath, 'utf-8');

      expect(content).toContain('[project]');
      expect(content).toContain('[commands.plan]');
      expect(content).toContain('[commands.implement]');
      expect(content).toContain('[commands.review]');
      expect(content).toContain('[workflow]');
      expect(content).toContain('[quality]');
    });

    it('should support custom model configuration', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'gemini',
        dryRun: false,
        variables: {
          geminiModel: 'gemini-pro',
          temperature: 0.5,
          maxTokens: 16384,
          topP: 0.9,
          topK: 50
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const settingsJsonPath = path.join(homeDir, '.gemini', 'settings.json');
      const content = await fs.readFile(settingsJsonPath, 'utf-8');
      const config = JSON.parse(content);

      expect(config.model).toBe('gemini-pro');
      expect(config.temperature).toBe(0.5);
      expect(config.maxOutputTokens).toBe(16384);
      expect(config.topP).toBe(0.9);
      expect(config.topK).toBe(50);
    });
  });
});

// Helper function
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
