// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 为Claude适配器补充单元测试

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { ClaudeAdapter } from '../src/claude.js';
import { ApplyContext } from '../src/index.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('ClaudeAdapter', () => {
  let adapter: ClaudeAdapter;
  let testDir: string;
  let homeDir: string;

  beforeEach(async () => {
    // 创建临时测试目录
    testDir = path.join(os.tmpdir(), `claude-test-${Date.now()}`);
    homeDir = path.join(testDir, 'home');
    await fs.mkdir(homeDir, { recursive: true });
    await fs.mkdir(testDir, { recursive: true });

    // Mock os.homedir
    vi.spyOn(os, 'homedir').mockReturnValue(homeDir);
    
    // Mock process.cwd
    vi.spyOn(process, 'cwd').mockReturnValue(testDir);

    adapter = new ClaudeAdapter();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('plan', () => {
    it('should return changes for new installation', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.changes).toBeDefined();
      expect(result.changes.length).toBeGreaterThan(0);
      expect(result.summary).toContain('Claude');
    });

    it('should detect create operation when files do not exist', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.changes.every(c => c.kind === 'create')).toBe(true);
    });

    it('should detect update operation when files already exist', async () => {
      // Arrange
      const claudeDir = path.join(homeDir, '.claude');
      await fs.mkdir(claudeDir, { recursive: true });
      await fs.writeFile(path.join(claudeDir, 'claude.json'), '{}', 'utf-8');
      await fs.writeFile(path.join(testDir, 'CLAUDE.md'), '# Old', 'utf-8');

      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      expect(result.changes.some(c => c.kind === 'update')).toBe(true);
    });

    it('should include all expected config files in changes', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      const result = await adapter.plan(ctx);

      // Assert
      const paths = result.changes.map(c => c.path);
      expect(paths.some(p => p.includes('claude.json'))).toBe(true);
      expect(paths.some(p => p.includes('CLAUDE.md'))).toBe(true);
      expect(paths.some(p => p.includes('CLAUDE.local.md'))).toBe(true);
    });
  });

  describe('apply', () => {
    it('should create all config files successfully', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'TestProject',
          persona: 'You are a test assistant'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeJsonPath = path.join(homeDir, '.claude', 'claude.json');
      const claudeMdPath = path.join(testDir, 'CLAUDE.md');
      const localMdPath = path.join(testDir, 'CLAUDE.local.md');

      const claudeJsonExists = await fileExists(claudeJsonPath);
      const claudeMdExists = await fileExists(claudeMdPath);
      const localMdExists = await fileExists(localMdPath);

      expect(claudeJsonExists).toBe(true);
      expect(claudeMdExists).toBe(true);
      expect(localMdExists).toBe(true);
    });

    it('should skip file creation in dry run mode', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: true,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeDir = path.join(homeDir, '.claude');
      const dirExists = await fileExists(claudeDir);
      expect(dirExists).toBe(false);
    });

    it('should replace variables in generated content', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'MyAwesomeProject',
          persona: 'Expert AI assistant',
          techStack: ['TypeScript', 'React'],
          codingStyle: 'functional'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeMdPath = path.join(testDir, 'CLAUDE.md');
      const content = await fs.readFile(claudeMdPath, 'utf-8');
      
      expect(content).toContain('MyAwesomeProject');
      expect(content).toContain('Expert AI assistant');
    });

    it('should generate valid JSON config file', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          apiKey: 'test-key-123',
          model: 'claude-3-opus',
          temperature: 0.7,
          maxTokens: 8000
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeJsonPath = path.join(homeDir, '.claude', 'claude.json');
      const content = await fs.readFile(claudeJsonPath, 'utf-8');
      
      // Should be valid JSON
      expect(() => JSON.parse(content)).not.toThrow();
      
      const config = JSON.parse(content);
      expect(config).toBeDefined();
    });

    it('should create backup before updating existing file', async () => {
      // Arrange
      const claudeDir = path.join(homeDir, '.claude');
      await fs.mkdir(claudeDir, { recursive: true });
      const originalContent = '{"old": "config"}';
      await fs.writeFile(path.join(claudeDir, 'claude.json'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert - 备份应该已创建（在 .meteor-shower/backups 中）
      const backupDir = path.join(testDir, '.meteor-shower', 'backups');
      const backupExists = await fileExists(backupDir);
      
      if (backupExists) {
        const backupFiles = await fs.readdir(backupDir);
        expect(backupFiles.some(f => f.includes('claude.json'))).toBe(true);
      }
    });

    it('should handle array variables in templates', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'ArrayTest',
          techStack: ['Node.js', 'Express', 'MongoDB']
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeMdPath = path.join(testDir, 'CLAUDE.md');
      const content = await fs.readFile(claudeMdPath, 'utf-8');
      
      // 如果模板使用 {{#each techStack}}，应该包含所有项
      expect(content).toContain('ArrayTest');
    });
  });

  describe('rollback', () => {
    it('should restore files from backup', async () => {
      // Arrange
      const claudeDir = path.join(homeDir, '.claude');
      await fs.mkdir(claudeDir, { recursive: true });
      
      const originalContent = '{"version": "original"}';
      await fs.writeFile(path.join(claudeDir, 'claude.json'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // 应用配置（会创建备份）
      await adapter.apply(ctx);

      // 修改文件
      const modifiedContent = '{"version": "modified"}';
      await fs.writeFile(path.join(claudeDir, 'claude.json'), modifiedContent, 'utf-8');

      // Act
      await adapter.rollback(ctx);

      // Assert - 文件应该恢复到备份状态
      // 注意：实际回滚可能需要有备份路径信息
    });

    it('should handle rollback when no backup exists', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act & Assert - 不应抛出错误
      await expect(adapter.rollback(ctx)).resolves.not.toThrow();
    });
  });

  describe('Error handling', () => {
    it('should handle file write errors gracefully', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Mock fs.writeFile to throw error
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockRejectedValueOnce(new Error('Write error'));

      // Act & Assert
      await expect(adapter.apply(ctx)).rejects.toThrow();

      // Cleanup
      fs.writeFile = originalWriteFile;
    });

    it('should rollback on apply failure', async () => {
      // Arrange
      const claudeDir = path.join(homeDir, '.claude');
      await fs.mkdir(claudeDir, { recursive: true });
      await fs.writeFile(path.join(claudeDir, 'claude.json'), 'original', 'utf-8');

      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Mock to cause failure partway through
      let writeCount = 0;
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockImplementation(async (...args: any[]) => {
        writeCount++;
        if (writeCount > 1) {
          throw new Error('Simulated failure');
        }
        return originalWriteFile.apply(fs, args as any);
      });

      // Act
      try {
        await adapter.apply(ctx);
      } catch (error) {
        // Expected to fail
      }

      // Cleanup
      fs.writeFile = originalWriteFile;
    });
  });

  describe('Integration scenarios', () => {
    it('should complete full workflow: plan -> apply -> rollback', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'FullWorkflow',
          persona: 'Integration test'
        }
      };

      // Act 1: Plan
      const planResult = await adapter.plan(ctx);
      expect(planResult.changes.length).toBeGreaterThan(0);

      // Act 2: Apply
      await adapter.apply(ctx);
      
      const claudeMdPath = path.join(testDir, 'CLAUDE.md');
      const mdExists = await fileExists(claudeMdPath);
      expect(mdExists).toBe(true);

      // Act 3: Rollback (if needed)
      await adapter.rollback(ctx);
      
      // Test completes without errors
    });

    it('should handle multiple apply calls idempotently', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'Idempotent'
        }
      };

      // Act - Apply multiple times
      await adapter.apply(ctx);
      await adapter.apply(ctx);
      await adapter.apply(ctx);

      // Assert - Files should still exist and be valid
      const claudeJsonPath = path.join(homeDir, '.claude', 'claude.json');
      const content = await fs.readFile(claudeJsonPath, 'utf-8');
      expect(() => JSON.parse(content)).not.toThrow();
    });
  });

  describe('Content generation', () => {
    it('should generate Markdown config with proper structure', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {
          projectName: 'StructureTest',
          persona: 'Structure validator'
        }
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const claudeMdPath = path.join(testDir, 'CLAUDE.md');
      const content = await fs.readFile(claudeMdPath, 'utf-8');
      
      // Should contain markdown headers
      expect(content).toMatch(/^#/m);
      expect(content).toContain('StructureTest');
    });

    it('should generate local config with instructions', async () => {
      // Arrange
      const ctx: ApplyContext = {
        target: 'claude',
        dryRun: false,
        variables: {}
      };

      // Act
      await adapter.apply(ctx);

      // Assert
      const localMdPath = path.join(testDir, 'CLAUDE.local.md');
      const content = await fs.readFile(localMdPath, 'utf-8');
      
      expect(content).toContain('本地');
      expect(content.length).toBeGreaterThan(0);
    });
  });
});

// Helper function
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
