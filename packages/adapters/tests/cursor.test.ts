// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 为Cursor适配器补充单元测试

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { CursorAdapter } from '../src/cursor.js';
import { ApplyContext } from '../src/index.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('CursorAdapter', () => {
  let adapter: CursorAdapter;
  let testDir: string;

  beforeEach(async () => {
    testDir = path.join(os.tmpdir(), `cursor-test-${Date.now()}`);
    await fs.mkdir(testDir, { recursive: true });
    
    vi.spyOn(process, 'cwd').mockReturnValue(testDir);
    
    adapter = new CursorAdapter();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('plan', () => {
    it('should return changes for new Cursor installation', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes).toBeDefined();
      expect(result.changes.length).toBeGreaterThan(0);
      expect(result.summary).toContain('Cursor');
    });

    it('should detect create operations for non-existent files', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes.every(c => c.kind === 'create')).toBe(true);
    });

    it('should detect update operations when files exist', async () => {
      await fs.writeFile(path.join(testDir, '.cursorrules'), 'old rules', 'utf-8');
      
      const cursorDir = path.join(testDir, '.cursor');
      await fs.mkdir(cursorDir, { recursive: true });
      await fs.writeFile(path.join(cursorDir, 'rules.txt'), 'old', 'utf-8');

      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes.some(c => c.kind === 'update')).toBe(true);
    });

    it('should include all expected config files', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);
      const paths = result.changes.map(c => c.path);

      expect(paths.some(p => p.includes('.cursorrules'))).toBe(true);
      expect(paths.some(p => p.includes('.cursor/rules.txt'))).toBe(true);
      expect(paths.some(p => p.includes('CURSOR.local.md'))).toBe(true);
    });
  });

  describe('apply', () => {
    it('should create all Cursor config files', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'TestProject',
          persona: 'Senior developer'
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const rulesTxtPath = path.join(testDir, '.cursor', 'rules.txt');
      const localMdPath = path.join(testDir, 'CURSOR.local.md');

      expect(await fileExists(cursorrulesPath)).toBe(true);
      expect(await fileExists(rulesTxtPath)).toBe(true);
      expect(await fileExists(localMdPath)).toBe(true);
    });

    it('should skip creation in dry run mode', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: true,
        variables: {}
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      expect(await fileExists(cursorrulesPath)).toBe(false);
    });

    it('should replace variables in generated rules', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'MyAwesomeApp',
          persona: 'Expert architect',
          codingStyle: 'clean-code'
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const content = await fs.readFile(cursorrulesPath, 'utf-8');

      expect(content).toContain('MyAwesomeApp');
      expect(content).toContain('Expert architect');
    });

    it('should generate comprehensive rules content', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'ComprehensiveTest'
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const content = await fs.readFile(cursorrulesPath, 'utf-8');

      expect(content).toContain('#');
      expect(content.length).toBeGreaterThan(100);
    });

    it('should create backup before updating existing rules', async () => {
      const originalRules = '# Original rules\n- Old style';
      await fs.writeFile(path.join(testDir, '.cursorrules'), originalRules, 'utf-8');

      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const backupDir = path.join(testDir, '.meteor-shower', 'backups');
      if (await fileExists(backupDir)) {
        const backupFiles = await fs.readdir(backupDir);
        expect(backupFiles.some(f => f.includes('cursorrules'))).toBe(true);
      }
    });

    it('should handle tech stack arrays in rules', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'TechStack',
          techStack: ['TypeScript', 'React', 'Node.js']
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const content = await fs.readFile(cursorrulesPath, 'utf-8');

      expect(content).toContain('TechStack');
    });
  });

  describe('rollback', () => {
    it('should restore files from backup', async () => {
      const originalContent = '# Original';
      await fs.writeFile(path.join(testDir, '.cursorrules'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const modifiedContent = '# Modified';
      await fs.writeFile(path.join(testDir, '.cursorrules'), modifiedContent, 'utf-8');

      await adapter.rollback(ctx);
    });

    it('should handle rollback gracefully when no backup exists', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      await expect(adapter.rollback(ctx)).resolves.not.toThrow();
    });
  });

  describe('Error handling', () => {
    it('should handle file write errors', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockRejectedValueOnce(new Error('Write failed'));

      await expect(adapter.apply(ctx)).rejects.toThrow();

      fs.writeFile = originalWriteFile;
    });

    it('should rollback on partial failure', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      let callCount = 0;
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockImplementation(async (...args: any[]) => {
        callCount++;
        if (callCount > 1) {
          throw new Error('Partial failure');
        }
        return originalWriteFile.apply(fs, args as any);
      });

      try {
        await adapter.apply(ctx);
      } catch (error) {
        // Expected
      }

      fs.writeFile = originalWriteFile;
    });
  });

  describe('Integration scenarios', () => {
    it('should complete full workflow successfully', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'FullWorkflow',
          persona: 'Integration tester'
        }
      };

      const planResult = await adapter.plan(ctx);
      expect(planResult.changes.length).toBeGreaterThan(0);

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      expect(await fileExists(cursorrulesPath)).toBe(true);

      await adapter.rollback(ctx);
    });

    it('should handle multiple applies idempotently', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'Idempotent'
        }
      };

      await adapter.apply(ctx);
      await adapter.apply(ctx);
      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const content = await fs.readFile(cursorrulesPath, 'utf-8');
      expect(content.length).toBeGreaterThan(0);
    });

    it('should create proper directory structure', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const cursorDir = path.join(testDir, '.cursor');
      expect(await fileExists(cursorDir)).toBe(true);

      const rulesTxt = path.join(cursorDir, 'rules.txt');
      expect(await fileExists(rulesTxt)).toBe(true);
    });
  });

  describe('Content generation', () => {
    it('should generate rules with proper markdown structure', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'MarkdownTest'
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const content = await fs.readFile(cursorrulesPath, 'utf-8');

      expect(content).toMatch(/^#/m);
      expect(content).toContain('MarkdownTest');
    });

    it('should generate local config with development tips', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const localMdPath = path.join(testDir, 'CURSOR.local.md');
      const content = await fs.readFile(localMdPath, 'utf-8');

      expect(content).toContain('本地');
      expect(content.length).toBeGreaterThan(0);
    });

    it('should generate both long and short format rules', async () => {
      const ctx: ApplyContext = {
        target: 'cursor',
        dryRun: false,
        variables: {
          projectName: 'DualFormat'
        }
      };

      await adapter.apply(ctx);

      const cursorrulesPath = path.join(testDir, '.cursorrules');
      const rulesTxtPath = path.join(testDir, '.cursor', 'rules.txt');

      const longContent = await fs.readFile(cursorrulesPath, 'utf-8');
      const shortContent = await fs.readFile(rulesTxtPath, 'utf-8');

      expect(longContent.length).toBeGreaterThan(shortContent.length);
      expect(shortContent).toContain('DualFormat');
    });
  });
});

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
