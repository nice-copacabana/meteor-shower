// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 为OpenAI适配器补充单元测试

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { OpenAIAdapter } from '../src/openai.js';
import { ApplyContext } from '../src/index.js';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

describe('OpenAIAdapter', () => {
  let adapter: OpenAIAdapter;
  let testDir: string;

  beforeEach(async () => {
    testDir = path.join(os.tmpdir(), `openai-test-${Date.now()}`);
    await fs.mkdir(testDir, { recursive: true });
    
    vi.spyOn(process, 'cwd').mockReturnValue(testDir);
    
    adapter = new OpenAIAdapter();
  });

  afterEach(async () => {
    vi.restoreAllMocks();
    
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // 忽略清理错误
    }
  });

  describe('plan', () => {
    it('should return changes for new OpenAI setup', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes).toBeDefined();
      expect(result.changes.length).toBeGreaterThan(0);
      expect(result.summary).toContain('OpenAI');
    });

    it('should detect create operations for new files', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes.every(c => c.kind === 'create')).toBe(true);
    });

    it('should detect update operations when files exist', async () => {
      await fs.writeFile(path.join(testDir, 'AGENTS.md'), '# Old', 'utf-8');
      await fs.writeFile(path.join(testDir, '.env.example'), 'OLD=value', 'utf-8');

      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);

      expect(result.changes.some(c => c.kind === 'update')).toBe(true);
    });

    it('should include all expected config files', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      const result = await adapter.plan(ctx);
      const paths = result.changes.map(c => c.path);

      expect(paths.some(p => p.includes('AGENTS.md'))).toBe(true);
      expect(paths.some(p => p.includes('.env.example'))).toBe(true);
      expect(paths.some(p => p.includes('OPENAI.local.md'))).toBe(true);
    });
  });

  describe('apply', () => {
    it('should create all OpenAI config files', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'TestProject',
          persona: 'AI expert'
        }
      };

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      const envPath = path.join(testDir, '.env.example');
      const localMdPath = path.join(testDir, 'OPENAI.local.md');

      expect(await fileExists(agentsMdPath)).toBe(true);
      expect(await fileExists(envPath)).toBe(true);
      expect(await fileExists(localMdPath)).toBe(true);
    });

    it('should skip creation in dry run mode', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: true,
        variables: {}
      };

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      expect(await fileExists(agentsMdPath)).toBe(false);
    });

    it('should replace variables in AGENTS.md', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'MyAIApp',
          persona: 'Expert assistant',
          techStack: ['Python', 'FastAPI', 'PostgreSQL']
        }
      };

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      const content = await fs.readFile(agentsMdPath, 'utf-8');

      expect(content).toContain('MyAIApp');
      expect(content).toContain('Expert assistant');
    });

    it('should generate .env.example with API keys section', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'EnvTest'
        }
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('OPENAI_API_KEY');
      expect(content).toContain('EnvTest');
    });

    it('should include database config when features.database is true', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'DatabaseApp',
          features: { database: true }
        }
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('DATABASE_URL');
      expect(content).toContain('REDIS_URL');
    });

    it('should not include database config when features.database is false', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'NoDatabaseApp',
          features: { database: false }
        }
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).not.toContain('DATABASE_URL');
    });

    it('should create backup before updating existing files', async () => {
      const originalContent = '# Original AGENTS.md';
      await fs.writeFile(path.join(testDir, 'AGENTS.md'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const backupDir = path.join(testDir, '.meteor-shower', 'backups');
      if (await fileExists(backupDir)) {
        const backupFiles = await fs.readdir(backupDir);
        expect(backupFiles.some(f => f.includes('AGENTS.md'))).toBe(true);
      }
    });

    it('should handle tech stack arrays', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'TechStackTest',
          techStack: ['Node.js', 'Express', 'MongoDB']
        }
      };

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      const content = await fs.readFile(agentsMdPath, 'utf-8');

      expect(content).toContain('TechStackTest');
    });
  });

  describe('rollback', () => {
    it('should restore files from backup', async () => {
      const originalContent = '# Original';
      await fs.writeFile(path.join(testDir, 'AGENTS.md'), originalContent, 'utf-8');

      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const modifiedContent = '# Modified';
      await fs.writeFile(path.join(testDir, 'AGENTS.md'), modifiedContent, 'utf-8');

      await adapter.rollback(ctx);
    });

    it('should handle rollback gracefully when no backup exists', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await expect(adapter.rollback(ctx)).resolves.not.toThrow();
    });
  });

  describe('Error handling', () => {
    it('should handle file write errors', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockRejectedValueOnce(new Error('Write failed'));

      await expect(adapter.apply(ctx)).rejects.toThrow();

      fs.writeFile = originalWriteFile;
    });

    it('should rollback on apply failure', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      let callCount = 0;
      const originalWriteFile = fs.writeFile;
      vi.spyOn(fs, 'writeFile').mockImplementation(async (...args: any[]) => {
        callCount++;
        if (callCount > 1) {
          throw new Error('Partial failure');
        }
        return originalWriteFile.apply(fs, args as any);
      });

      try {
        await adapter.apply(ctx);
      } catch (error) {
        // Expected
      }

      fs.writeFile = originalWriteFile;
    });
  });

  describe('Integration scenarios', () => {
    it('should complete full workflow successfully', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'FullWorkflow',
          persona: 'Integration tester'
        }
      };

      const planResult = await adapter.plan(ctx);
      expect(planResult.changes.length).toBeGreaterThan(0);

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      expect(await fileExists(agentsMdPath)).toBe(true);

      await adapter.rollback(ctx);
    });

    it('should handle multiple applies idempotently', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'Idempotent'
        }
      };

      await adapter.apply(ctx);
      await adapter.apply(ctx);
      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      const content = await fs.readFile(agentsMdPath, 'utf-8');
      expect(content.length).toBeGreaterThan(0);
    });
  });

  describe('Content generation', () => {
    it('should generate AGENTS.md with proper structure', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          projectName: 'StructureTest',
          persona: 'Test persona'
        }
      };

      await adapter.apply(ctx);

      const agentsMdPath = path.join(testDir, 'AGENTS.md');
      const content = await fs.readFile(agentsMdPath, 'utf-8');

      expect(content).toMatch(/^#/m);
      expect(content).toContain('StructureTest');
      expect(content).toContain('Test persona');
    });

    it('should generate .env.example with security section', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('JWT_SECRET');
      expect(content).toContain('CORS_ORIGIN');
    });

    it('should generate local config with instructions', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const localMdPath = path.join(testDir, 'OPENAI.local.md');
      const content = await fs.readFile(localMdPath, 'utf-8');

      expect(content).toContain('本地');
      expect(content.length).toBeGreaterThan(0);
    });

    it('should use default model when not specified', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('OPENAI_MODEL');
    });

    it('should include rate limiting configuration', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {}
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('RATE_LIMIT');
    });
  });

  describe('Variable customization', () => {
    it('should use custom model configuration', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          defaultModel: 'gpt-4-turbo',
          temperature: 0.5,
          maxTokens: 8000
        }
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('gpt-4-turbo');
      expect(content).toContain('0.5');
      expect(content).toContain('8000');
    });

    it('should use custom port configuration', async () => {
      const ctx: ApplyContext = {
        target: 'openai',
        dryRun: false,
        variables: {
          port: 8080
        }
      };

      await adapter.apply(ctx);

      const envPath = path.join(testDir, '.env.example');
      const content = await fs.readFile(envPath, 'utf-8');

      expect(content).toContain('8080');
    });
  });
});

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
