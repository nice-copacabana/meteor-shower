// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: ÂÆûÁé∞CLI mcpÂëΩ‰ª§ÂÆûÈôÖÊúçÂä°Êé¢ÊµãÔºåÊ£ÄÊµãÂíåÊµãËØïMCPÊúçÂä°ÂèØÁî®ÊÄß
import chalk from 'chalk';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';
const execAsync = promisify(exec);
/**
 * MCP ÊµãËØïÂëΩ‰ª§
 * Êé¢ÊµãÂíåÊµãËØïÈÖçÁΩÆÁöÑ MCP ÊúçÂä°ÂèØÁî®ÊÄß
 */
export async function mcpTestCommand() {
    console.log(chalk.cyan('üîß ÊµãËØï MCP ÊúçÂä°ÂèØÁî®ÊÄß...'));
    try {
        // Ê≠•È™§1: Âä†ËΩΩ MCP ÈÖçÁΩÆ
        console.log(chalk.gray('üìö Âä†ËΩΩ MCP ÈÖçÁΩÆ...'));
        const services = await loadMCPServices();
        if (services.length === 0) {
            console.log(chalk.yellow('\n‚ö†Ô∏è Êú™ÊâæÂà∞ MCP ÊúçÂä°ÈÖçÁΩÆ'));
            console.log(chalk.gray('ÊèêÁ§∫: Âú® Claude Desktop ÈÖçÁΩÆÊñá‰ª∂‰∏≠Ê∑ªÂä† MCP ÊúçÂä°'));
            console.log(chalk.gray('ÈÖçÁΩÆÊñá‰ª∂‰ΩçÁΩÆ:'));
            console.log(chalk.gray('  - macOS: ~/Library/Application Support/Claude/claude_desktop_config.json'));
            console.log(chalk.gray('  - Windows: %APPDATA%\\Claude\\claude_desktop_config.json'));
            return;
        }
        console.log(chalk.green(`‚úÖ ÂèëÁé∞ ${services.length} ‰∏™ MCP ÊúçÂä°\n`));
        // Ê≠•È™§2: ÊµãËØïÊØè‰∏™ÊúçÂä°
        console.log(chalk.cyan('üîç Ê≠£Âú®ÊµãËØïÊúçÂä°...\n'));
        const results = [];
        for (const service of services) {
            const result = await testMCPService(service);
            results.push(result);
            displayServiceResult(result);
        }
        // Ê≠•È™§3: ÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
        console.log(chalk.yellow('\nüìä MCP ÊúçÂä°Áä∂ÊÄÅÊ±áÊÄª:'));
        displaySummary(results);
        // Ê≠•È™§4: Êèê‰æõÊïÖÈöúÊéíÊü•Âª∫ËÆÆ
        const offlineServices = results.filter(s => s.status === 'offline');
        if (offlineServices.length > 0) {
            console.log(chalk.yellow('\nüí° ÊïÖÈöúÊéíÊü•Âª∫ËÆÆ:'));
            offlineServices.forEach(service => {
                console.log(chalk.gray(`\n  ${service.name}:`));
                if (service.type === 'stdio') {
                    console.log(chalk.gray(`    1. Ê£ÄÊü•ÂëΩ‰ª§ÊòØÂê¶ÂèØÁî®: ${service.command}`));
                    console.log(chalk.gray(`    2. È™åËØÅ‰æùËµñÊòØÂê¶ÂÆâË£Ö`));
                    console.log(chalk.gray(`    3. Ê£ÄÊü•ÁéØÂ¢ÉÂèòÈáèÈÖçÁΩÆ`));
                }
                else {
                    console.log(chalk.gray(`    1. Ê£ÄÊü•ÊúçÂä°ÊòØÂê¶ËøêË°å: ${service.endpoint}`));
                    console.log(chalk.gray(`    2. È™åËØÅÁΩëÁªúËøûÊé•`));
                    console.log(chalk.gray(`    3. Ê£ÄÊü•Èò≤ÁÅ´Â¢ôËÆæÁΩÆ`));
                }
            });
        }
    }
    catch (error) {
        console.error(chalk.red(`\n‚ùå ÊµãËØïÂ§±Ë¥•: ${error.message}`));
    }
}
/**
 * Âä†ËΩΩ MCP ÊúçÂä°ÈÖçÁΩÆ
 * ‰ªé Claude Desktop ÈÖçÁΩÆÊñá‰ª∂‰∏≠ËØªÂèñ MCP ÊúçÂä°ÂÆö‰πâ
 */
async function loadMCPServices() {
    const services = [];
    // Á°ÆÂÆöÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑ
    const homeDir = os.homedir();
    const platform = os.platform();
    let configPath;
    if (platform === 'darwin') {
        configPath = path.join(homeDir, 'Library/Application Support/Claude/claude_desktop_config.json');
    }
    else if (platform === 'win32') {
        configPath = path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
    }
    else {
        // Linux
        configPath = path.join(homeDir, '.config/Claude/claude_desktop_config.json');
    }
    try {
        // ËØªÂèñÈÖçÁΩÆÊñá‰ª∂
        const configContent = await fs.readFile(configPath, 'utf-8');
        const config = JSON.parse(configContent);
        // Ëß£ÊûêÊúçÂä°ÈÖçÁΩÆ
        if (config.mcpServers) {
            for (const [name, serverConfig] of Object.entries(config.mcpServers)) {
                services.push({
                    name,
                    type: 'stdio',
                    command: serverConfig.command,
                    args: serverConfig.args || [],
                    status: 'unknown'
                });
            }
        }
    }
    catch (error) {
        if (error.code === 'ENOENT') {
            // ÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®ÔºåËøîÂõûÈªòËÆ§ÊúçÂä°ÂàóË°®Áî®‰∫éÊµãËØï
            return getDefaultMCPServices();
        }
        throw error;
    }
    return services;
}
/**
 * Ëé∑ÂèñÈªòËÆ§ MCP ÊúçÂä°ÂàóË°®ÔºàÁî®‰∫éÊºîÁ§∫Ôºâ
 */
function getDefaultMCPServices() {
    return [
        {
            name: 'filesystem',
            type: 'stdio',
            command: 'npx',
            args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()],
            status: 'unknown'
        },
        {
            name: 'github',
            type: 'stdio',
            command: 'npx',
            args: ['-y', '@modelcontextprotocol/server-github'],
            status: 'unknown'
        },
        {
            name: 'brave-search',
            type: 'stdio',
            command: 'npx',
            args: ['-y', '@modelcontextprotocol/server-brave-search'],
            status: 'unknown'
        }
    ];
}
/**
 * ÊµãËØïÂçï‰∏™ MCP ÊúçÂä°
 */
async function testMCPService(service) {
    const startTime = Date.now();
    try {
        if (service.type === 'stdio') {
            // ÊµãËØï stdio Á±ªÂûãÊúçÂä°
            await testStdioService(service);
            service.latency = Date.now() - startTime;
            service.status = 'online';
        }
        else if (service.type === 'http' || service.type === 'sse') {
            // ÊµãËØï HTTP/SSE Á±ªÂûãÊúçÂä°
            await testHttpService(service);
            service.latency = Date.now() - startTime;
            service.status = 'online';
        }
    }
    catch (error) {
        service.status = 'offline';
        service.error = error.message;
        service.latency = Date.now() - startTime;
    }
    return service;
}
/**
 * ÊµãËØï stdio Á±ªÂûã MCP ÊúçÂä°
 */
async function testStdioService(service) {
    // Ê£ÄÊü•ÂëΩ‰ª§ÊòØÂê¶Â≠òÂú®
    const command = service.command;
    const testCommand = os.platform() === 'win32'
        ? `where ${command}`
        : `which ${command}`;
    try {
        await execAsync(testCommand);
        // Â∞ùËØïÂêØÂä®ÊúçÂä°Âπ∂Ê£ÄÊµãÂìçÂ∫îÔºàË∂ÖÊó∂ 2 ÁßíÔºâ
        const fullCommand = `${command} ${(service.args || []).join(' ')}`;
        const timeout = 2000;
        await Promise.race([
            execAsync(fullCommand, { timeout }),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), timeout))
        ]);
    }
    catch (error) {
        // Timeout ÊòØÈ¢ÑÊúüÁöÑÔºåÂõ†‰∏∫ MCP ÊúçÂä°‰ºöÊåÅÁª≠ËøêË°å
        if (error.message === 'Timeout' || error.killed) {
            return; // ÊúçÂä°Ê≠£Â∏∏ÂêØÂä®
        }
        throw new Error(`ÂëΩ‰ª§‰∏çÂèØÁî®: ${command}`);
    }
}
/**
 * ÊµãËØï HTTP/SSE Á±ªÂûã MCP ÊúçÂä°
 */
async function testHttpService(service) {
    // TODO: ÂÆûÁé∞ HTTP ËØ∑Ê±ÇÊµãËØï
    // const response = await fetch(service.endpoint!);
    // if (!response.ok) {
    //   throw new Error(`HTTP ${response.status}`);
    // }
    throw new Error('HTTP ÊúçÂä°ÊµãËØïÂ∞öÊú™ÂÆûÁé∞');
}
/**
 * ÊòæÁ§∫Âçï‰∏™ÊúçÂä°ÁöÑÊµãËØïÁªìÊûú
 */
function displayServiceResult(service) {
    const icon = service.status === 'online' ? '‚úÖ' : '‚ùå';
    const color = service.status === 'online' ? 'green' : 'red';
    console.log(chalk[color](`${icon} ${service.name}`));
    console.log(chalk.gray(`   Á±ªÂûã: ${service.type}`));
    if (service.type === 'stdio') {
        console.log(chalk.gray(`   ÂëΩ‰ª§: ${service.command} ${(service.args || []).join(' ')}`));
    }
    else {
        console.log(chalk.gray(`   Á´ØÁÇπ: ${service.endpoint}`));
    }
    if (service.status === 'online') {
        console.log(chalk.gray(`   Âª∂Ëøü: ${service.latency}ms`));
        if (service.version) {
            console.log(chalk.gray(`   ÁâàÊú¨: ${service.version}`));
        }
    }
    else {
        console.log(chalk.red(`   ÈîôËØØ: ${service.error}`));
    }
    console.log(); // Á©∫Ë°å
}
/**
 * ÊòæÁ§∫Ê±áÊÄª‰ø°ÊÅØ
 */
function displaySummary(services) {
    const onlineCount = services.filter(s => s.status === 'online').length;
    const offlineCount = services.filter(s => s.status === 'offline').length;
    const total = services.length;
    console.log(chalk.gray(`  ÊÄªËÆ°: ${total} ‰∏™ÊúçÂä°`));
    console.log(chalk.green(`  ‚úÖ Âú®Á∫ø: ${onlineCount}`));
    console.log(chalk.red(`  ‚ùå Á¶ªÁ∫ø: ${offlineCount}`));
    if (onlineCount > 0) {
        const avgLatency = services
            .filter(s => s.status === 'online' && s.latency)
            .reduce((sum, s) => sum + (s.latency || 0), 0) / onlineCount;
        console.log(chalk.gray(`  Âπ≥ÂùáÂª∂Ëøü: ${avgLatency.toFixed(0)}ms`));
    }
    const healthPercentage = (onlineCount / total * 100).toFixed(0);
    const healthColor = onlineCount === total ? 'green' : onlineCount > 0 ? 'yellow' : 'red';
    console.log(chalk[healthColor](`  ÂÅ•Â∫∑Â∫¶: ${healthPercentage}%`));
}
