// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-15
// Task: CLIç”¨æˆ·å±‚çº§é›†æˆè¾…åŠ©æ¨¡å— - æä¾›é…é¢æ£€æŸ¥å’Œå‡çº§æç¤ºåŠŸèƒ½

/**
 * CLIç”¨æˆ·å±‚çº§è¾…åŠ©æ¨¡å—
 * 
 * ä¸ºCLIå‘½ä»¤æä¾›ç”¨æˆ·å±‚çº§æ£€æŸ¥ã€é…é¢éªŒè¯å’Œå‡çº§æç¤ºåŠŸèƒ½
 */

import chalk from 'chalk';
import path from 'path';
import os from 'os';
import fs from 'fs/promises';
import { DatabaseManager, createDatabaseManager } from 'meteor-shower-user-tier';
import { UserTier } from 'meteor-shower-user-tier';

/**
 * é…é¢æ£€æŸ¥ç»“æœ
 */
export interface QuotaCheckResult {
  allowed: boolean;
  reason?: string;
  current: number;
  limit: number;
  remaining: number;
  tier?: UserTier;
}

/**
 * å‡çº§å»ºè®®
 */
export interface UpgradeSuggestion {
  shouldUpgrade: boolean;
  currentTier: UserTier;
  suggestedTier?: UserTier;
  reason?: string;
  benefits?: string[];
}

/**
 * CLIç”¨æˆ·å±‚çº§è¾…åŠ©ç±»
 */
export class CLITierHelper {
  private dbManager: DatabaseManager | null = null;

  /**
   * åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
   */
  private async initDatabase(): Promise<DatabaseManager | null> {
    if (this.dbManager) {
      return this.dbManager;
    }

    try {
      const dbPath = process.env.METEOR_DB_PATH || path.join(os.homedir(), '.meteor-shower', 'meteor.db');
      
      // æ£€æŸ¥æ•°æ®åº“æ˜¯å¦å­˜åœ¨
      try {
        await fs.access(dbPath);
      } catch {
        // æ•°æ®åº“ä¸å­˜åœ¨ï¼Œè¿”å›null
        return null;
      }

      this.dbManager = createDatabaseManager({
        path: dbPath,
        wal: true,
      });

      return this.dbManager;
    } catch (error) {
      console.warn(chalk.yellow('âš ï¸  æ— æ³•è¿æ¥ç”¨æˆ·æ•°æ®åº“'));
      return null;
    }
  }

  /**
   * æ£€æŸ¥å·¥å…·é…ç½®é…é¢
   */
  async checkToolQuota(userId?: string): Promise<QuotaCheckResult> {
    if (!userId) {
      return this.allowByDefault();
    }

    const db = await this.initDatabase();
    if (!db) {
      return this.allowByDefault();
    }

    try {
      const user = await db.users.findById(userId);
      if (!user) {
        return this.allowByDefault();
      }

      const currentMonth = new Date().toISOString().slice(0, 7);
      const usage = await db.usageStats.findByUserAndMonth(userId, currentMonth);
      const toolsConfigured = usage?.toolsConfigured || 0;

      // è·å–é™åˆ¶
      const limits = this.getTierLimits(user.tier);
      const maxTools = limits.maxTools;

      if (maxTools === Infinity) {
        return {
          allowed: true,
          current: toolsConfigured,
          limit: -1,
          remaining: -1,
          tier: user.tier,
        };
      }

      const allowed = toolsConfigured < maxTools;
      return {
        allowed,
        reason: allowed ? undefined : `å·²è¾¾åˆ°å·¥å…·é…ç½®ä¸Šé™ (${maxTools})`,
        current: toolsConfigured,
        limit: maxTools,
        remaining: Math.max(0, maxTools - toolsConfigured),
        tier: user.tier,
      };
    } catch (error) {
      console.warn(chalk.yellow('âš ï¸  é…é¢æ£€æŸ¥å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œ'));
      return this.allowByDefault();
    }
  }

  /**
   * æ£€æŸ¥æ¨¡æ¿åˆ†äº«é…é¢
   */
  async checkTemplateQuota(userId?: string): Promise<QuotaCheckResult> {
    if (!userId) {
      return this.allowByDefault();
    }

    const db = await this.initDatabase();
    if (!db) {
      return this.allowByDefault();
    }

    try {
      const user = await db.users.findById(userId);
      if (!user) {
        return this.allowByDefault();
      }

      const currentMonth = new Date().toISOString().slice(0, 7);
      const usage = await db.usageStats.findByUserAndMonth(userId, currentMonth);
      const cloudTemplates = usage?.cloudTemplates || 0;

      // è·å–é™åˆ¶
      const limits = this.getTierLimits(user.tier);
      const maxTemplates = limits.maxCloudTemplates;

      if (maxTemplates === Infinity) {
        return {
          allowed: true,
          current: cloudTemplates,
          limit: -1,
          remaining: -1,
          tier: user.tier,
        };
      }

      const allowed = cloudTemplates < maxTemplates;
      return {
        allowed,
        reason: allowed ? undefined : `å·²è¾¾åˆ°äº‘ç«¯æ¨¡æ¿ä¸Šé™ (${maxTemplates})`,
        current: cloudTemplates,
        limit: maxTemplates,
        remaining: Math.max(0, maxTemplates - cloudTemplates),
        tier: user.tier,
      };
    } catch (error) {
      console.warn(chalk.yellow('âš ï¸  é…é¢æ£€æŸ¥å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œ'));
      return this.allowByDefault();
    }
  }

  /**
   * å¢åŠ å·¥å…·ä½¿ç”¨é‡
   */
  async incrementToolUsage(userId?: string): Promise<void> {
    if (!userId) return;

    const db = await this.initDatabase();
    if (!db) return;

    try {
      const currentMonth = new Date().toISOString().slice(0, 7);
      await db.usageStats.increment(userId, currentMonth, 'toolsConfigured', 1);
    } catch (error) {
      console.warn(chalk.yellow('âš ï¸  æ— æ³•æ›´æ–°ä½¿ç”¨é‡ç»Ÿè®¡'));
    }
  }

  /**
   * å¢åŠ æ¨¡æ¿ä½¿ç”¨é‡
   */
  async incrementTemplateUsage(userId?: string): Promise<void> {
    if (!userId) return;

    const db = await this.initDatabase();
    if (!db) return;

    try {
      const currentMonth = new Date().toISOString().slice(0, 7);
      await db.usageStats.increment(userId, currentMonth, 'cloudTemplates', 1);
    } catch (error) {
      console.warn(chalk.yellow('âš ï¸  æ— æ³•æ›´æ–°ä½¿ç”¨é‡ç»Ÿè®¡'));
    }
  }

  /**
   * æ˜¾ç¤ºé…é¢ä¿¡æ¯
   */
  displayQuotaInfo(quota: QuotaCheckResult): void {
    if (quota.limit === -1) {
      console.log(chalk.gray('  å½“å‰å±‚çº§: ') + chalk.cyan(quota.tier || 'FREE'));
      console.log(chalk.gray('  é…é¢: ') + chalk.green('æ— é™åˆ¶'));
    } else {
      console.log(chalk.gray('  å½“å‰å±‚çº§: ') + chalk.cyan(quota.tier || 'FREE'));
      console.log(chalk.gray('  é…é¢ä½¿ç”¨: ') + chalk.yellow(`${quota.current}/${quota.limit}`));
      console.log(chalk.gray('  å‰©ä½™: ') + chalk.green(`${quota.remaining}`));
    }
  }

  /**
   * æ˜¾ç¤ºå‡çº§æç¤º
   */
  displayUpgradePrompt(quota: QuotaCheckResult): void {
    if (!quota.allowed && quota.tier) {
      console.log(chalk.yellow('\nğŸ’¡ å‡çº§æç¤º:'));
      
      const suggestion = this.getUpgradeSuggestion(quota.tier);
      if (suggestion.shouldUpgrade && suggestion.suggestedTier) {
        console.log(chalk.gray(`   å»ºè®®å‡çº§åˆ°: ${chalk.cyan(suggestion.suggestedTier)}`));
        if (suggestion.benefits) {
          console.log(chalk.gray('   å‡çº§åå¯è·å¾—:'));
          suggestion.benefits.forEach(benefit => {
            console.log(chalk.gray(`     â€¢ ${benefit}`));
          });
        }
      }
      
      console.log(chalk.gray('   è¿è¡Œ ') + chalk.yellow('meteor-shower account upgrade') + chalk.gray(' æŸ¥çœ‹å‡çº§é€‰é¡¹'));
    }
  }

  /**
   * è·å–å‡çº§å»ºè®®
   */
  private getUpgradeSuggestion(currentTier: UserTier): UpgradeSuggestion {
    const tierOrder = [UserTier.FREE, UserTier.PRO, UserTier.TEAM, UserTier.ENTERPRISE];
    const currentIndex = tierOrder.indexOf(currentTier);

    if (currentIndex === tierOrder.length - 1) {
      return {
        shouldUpgrade: false,
        currentTier,
      };
    }

    const suggestedTier = tierOrder[currentIndex + 1];
    const benefits: string[] = [];

    switch (suggestedTier) {
      case UserTier.PRO:
        benefits.push('æ— é™å·¥å…·é…ç½®');
        benefits.push('æ— é™äº‘ç«¯æ¨¡æ¿');
        benefits.push('500æ¬¡/æœˆèƒ½åŠ›éªŒè¯');
        benefits.push('10GBå­˜å‚¨ç©ºé—´');
        break;
      case UserTier.TEAM:
        benefits.push('å›¢é˜Ÿåä½œåŠŸèƒ½');
        benefits.push('2000æ¬¡/æœˆèƒ½åŠ›éªŒè¯');
        benefits.push('100ä¸ªå¹¶å‘ä»»åŠ¡');
        benefits.push('å®¡è®¡æ—¥å¿—');
        break;
      case UserTier.ENTERPRISE:
        benefits.push('ä¼ä¸šçº§å®‰å…¨');
        benefits.push('æ— é™é…é¢');
        benefits.push('SSOå•ç‚¹ç™»å½•');
        benefits.push('ä¸“å±æ”¯æŒ');
        break;
    }

    return {
      shouldUpgrade: true,
      currentTier,
      suggestedTier,
      reason: `å½“å‰å±‚çº§é…é¢å·²ç”¨å°½`,
      benefits,
    };
  }

  /**
   * è·å–å±‚çº§é™åˆ¶
   */
  private getTierLimits(tier: UserTier) {
    const limits = {
      [UserTier.FREE]: {
        maxTools: 3,
        maxCloudTemplates: 5,
      },
      [UserTier.PRO]: {
        maxTools: Infinity,
        maxCloudTemplates: Infinity,
      },
      [UserTier.TEAM]: {
        maxTools: Infinity,
        maxCloudTemplates: Infinity,
      },
      [UserTier.ENTERPRISE]: {
        maxTools: Infinity,
        maxCloudTemplates: Infinity,
      },
    };

    return limits[tier];
  }

  /**
   * é»˜è®¤å…è®¸ï¼ˆæ— é…é¢é™åˆ¶ï¼‰
   */
  private allowByDefault(): QuotaCheckResult {
    return {
      allowed: true,
      current: 0,
      limit: -1,
      remaining: -1,
    };
  }

  /**
   * å…³é—­æ•°æ®åº“è¿æ¥
   */
  close(): void {
    if (this.dbManager) {
      this.dbManager.close();
      this.dbManager = null;
    }
  }
}

/**
 * åˆ›å»ºCLIå±‚çº§è¾…åŠ©å®ä¾‹
 */
export function createCLITierHelper(): CLITierHelper {
  return new CLITierHelper();
}
