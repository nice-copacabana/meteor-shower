// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: å®ç°CLI mcpå‘½ä»¤å®é™…æœåŠ¡æ¢æµ‹ï¼Œæ£€æµ‹å’Œæµ‹è¯•MCPæœåŠ¡å¯ç”¨æ€§

import chalk from 'chalk';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

const execAsync = promisify(exec);

/**
 * MCP æœåŠ¡ä¿¡æ¯
 */
interface MCPService {
  name: string;                  // æœåŠ¡åç§°
  type: 'http' | 'stdio' | 'sse'; // æœåŠ¡ç±»å‹
  endpoint?: string;             // HTTP/SSE ç«¯ç‚¹
  command?: string;              // stdio å‘½ä»¤
  args?: string[];               // stdio å‚æ•°
  status?: 'online' | 'offline' | 'unknown'; // æœåŠ¡çŠ¶æ€
  latency?: number;              // å“åº”å»¶è¿Ÿ(ms)
  error?: string;                // é”™è¯¯ä¿¡æ¯
  version?: string;              // æœåŠ¡ç‰ˆæœ¬
}

/**
 * MCP é…ç½®æ–‡ä»¶æ ¼å¼
 */
interface MCPConfig {
  mcpServers: Record<string, {
    command: string;
    args?: string[];
    env?: Record<string, string>;
  }>;
}

/**
 * MCP æµ‹è¯•å‘½ä»¤
 * æ¢æµ‹å’Œæµ‹è¯•é…ç½®çš„ MCP æœåŠ¡å¯ç”¨æ€§
 */
export async function mcpTestCommand() {
  console.log(chalk.cyan('ğŸ”§ æµ‹è¯• MCP æœåŠ¡å¯ç”¨æ€§...'));
  
  try {
    // æ­¥éª¤1: åŠ è½½ MCP é…ç½®
    console.log(chalk.gray('ğŸ“š åŠ è½½ MCP é…ç½®...'));
    const services = await loadMCPServices();
    
    if (services.length === 0) {
      console.log(chalk.yellow('\nâš ï¸ æœªæ‰¾åˆ° MCP æœåŠ¡é…ç½®'));
      console.log(chalk.gray('æç¤º: åœ¨ Claude Desktop é…ç½®æ–‡ä»¶ä¸­æ·»åŠ  MCP æœåŠ¡'));
      console.log(chalk.gray('é…ç½®æ–‡ä»¶ä½ç½®:'));
      console.log(chalk.gray('  - macOS: ~/Library/Application Support/Claude/claude_desktop_config.json'));
      console.log(chalk.gray('  - Windows: %APPDATA%\\Claude\\claude_desktop_config.json'));
      return;
    }

    console.log(chalk.green(`âœ… å‘ç° ${services.length} ä¸ª MCP æœåŠ¡\n`));

    // æ­¥éª¤2: æµ‹è¯•æ¯ä¸ªæœåŠ¡
    console.log(chalk.cyan('ğŸ” æ­£åœ¨æµ‹è¯•æœåŠ¡...\n'));
    const results: MCPService[] = [];
    
    for (const service of services) {
      const result = await testMCPService(service);
      results.push(result);
      displayServiceResult(result);
    }

    // æ­¥éª¤3: æ˜¾ç¤ºæ±‡æ€»ä¿¡æ¯
    console.log(chalk.yellow('\nğŸ“Š MCP æœåŠ¡çŠ¶æ€æ±‡æ€»:'));
    displaySummary(results);

    // æ­¥éª¤4: æä¾›æ•…éšœæ’æŸ¥å»ºè®®
    const offlineServices = results.filter(s => s.status === 'offline');
    if (offlineServices.length > 0) {
      console.log(chalk.yellow('\nğŸ’¡ æ•…éšœæ’æŸ¥å»ºè®®:'));
      offlineServices.forEach(service => {
        console.log(chalk.gray(`\n  ${service.name}:`));
        if (service.type === 'stdio') {
          console.log(chalk.gray(`    1. æ£€æŸ¥å‘½ä»¤æ˜¯å¦å¯ç”¨: ${service.command}`));
          console.log(chalk.gray(`    2. éªŒè¯ä¾èµ–æ˜¯å¦å®‰è£…`));
          console.log(chalk.gray(`    3. æ£€æŸ¥ç¯å¢ƒå˜é‡é…ç½®`));
        } else {
          console.log(chalk.gray(`    1. æ£€æŸ¥æœåŠ¡æ˜¯å¦è¿è¡Œ: ${service.endpoint}`));
          console.log(chalk.gray(`    2. éªŒè¯ç½‘ç»œè¿æ¥`));
          console.log(chalk.gray(`    3. æ£€æŸ¥é˜²ç«å¢™è®¾ç½®`));
        }
      });
    }

  } catch (error: any) {
    console.error(chalk.red(`\nâŒ æµ‹è¯•å¤±è´¥: ${error.message}`));
  }
}

/**
 * åŠ è½½ MCP æœåŠ¡é…ç½®
 * ä» Claude Desktop é…ç½®æ–‡ä»¶ä¸­è¯»å– MCP æœåŠ¡å®šä¹‰
 */
async function loadMCPServices(): Promise<MCPService[]> {
  const services: MCPService[] = [];
  
  // ç¡®å®šé…ç½®æ–‡ä»¶è·¯å¾„
  const homeDir = os.homedir();
  const platform = os.platform();
  
  let configPath: string;
  if (platform === 'darwin') {
    configPath = path.join(homeDir, 'Library/Application Support/Claude/claude_desktop_config.json');
  } else if (platform === 'win32') {
    configPath = path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
  } else {
    // Linux
    configPath = path.join(homeDir, '.config/Claude/claude_desktop_config.json');
  }

  try {
    // è¯»å–é…ç½®æ–‡ä»¶
    const configContent = await fs.readFile(configPath, 'utf-8');
    const config: MCPConfig = JSON.parse(configContent);

    // è§£ææœåŠ¡é…ç½®
    if (config.mcpServers) {
      for (const [name, serverConfig] of Object.entries(config.mcpServers)) {
        services.push({
          name,
          type: 'stdio',
          command: serverConfig.command,
          args: serverConfig.args || [],
          status: 'unknown'
        });
      }
    }
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      // é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›é»˜è®¤æœåŠ¡åˆ—è¡¨ç”¨äºæµ‹è¯•
      return getDefaultMCPServices();
    }
    throw error;
  }

  return services;
}

/**
 * è·å–é»˜è®¤ MCP æœåŠ¡åˆ—è¡¨ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
 */
function getDefaultMCPServices(): MCPService[] {
  return [
    {
      name: 'filesystem',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()],
      status: 'unknown'
    },
    {
      name: 'github',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-github'],
      status: 'unknown'
    },
    {
      name: 'brave-search',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-brave-search'],
      status: 'unknown'
    }
  ];
}

/**
 * æµ‹è¯•å•ä¸ª MCP æœåŠ¡
 */
async function testMCPService(service: MCPService): Promise<MCPService> {
  const startTime = Date.now();
  
  try {
    if (service.type === 'stdio') {
      // æµ‹è¯• stdio ç±»å‹æœåŠ¡
      await testStdioService(service);
      service.latency = Date.now() - startTime;
      service.status = 'online';
    } else if (service.type === 'http' || service.type === 'sse') {
      // æµ‹è¯• HTTP/SSE ç±»å‹æœåŠ¡
      await testHttpService(service);
      service.latency = Date.now() - startTime;
      service.status = 'online';
    }
  } catch (error: any) {
    service.status = 'offline';
    service.error = error.message;
    service.latency = Date.now() - startTime;
  }

  return service;
}

/**
 * æµ‹è¯• stdio ç±»å‹ MCP æœåŠ¡
 */
async function testStdioService(service: MCPService): Promise<void> {
  // æ£€æŸ¥å‘½ä»¤æ˜¯å¦å­˜åœ¨
  const command = service.command!;
  const testCommand = os.platform() === 'win32' 
    ? `where ${command}` 
    : `which ${command}`;
  
  try {
    await execAsync(testCommand);
    
    // å°è¯•å¯åŠ¨æœåŠ¡å¹¶æ£€æµ‹å“åº”ï¼ˆè¶…æ—¶ 2 ç§’ï¼‰
    const fullCommand = `${command} ${(service.args || []).join(' ')}`;
    const timeout = 2000;
    
    await Promise.race([
      execAsync(fullCommand, { timeout }),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeout)
      )
    ]);
  } catch (error: any) {
    // Timeout æ˜¯é¢„æœŸçš„ï¼Œå› ä¸º MCP æœåŠ¡ä¼šæŒç»­è¿è¡Œ
    if (error.message === 'Timeout' || error.killed) {
      return; // æœåŠ¡æ­£å¸¸å¯åŠ¨
    }
    throw new Error(`å‘½ä»¤ä¸å¯ç”¨: ${command}`);
  }
}

/**
 * æµ‹è¯• HTTP/SSE ç±»å‹ MCP æœåŠ¡
 */
async function testHttpService(service: MCPService): Promise<void> {
  // TODO: å®ç° HTTP è¯·æ±‚æµ‹è¯•
  // const response = await fetch(service.endpoint!);
  // if (!response.ok) {
  //   throw new Error(`HTTP ${response.status}`);
  // }
  throw new Error('HTTP æœåŠ¡æµ‹è¯•å°šæœªå®ç°');
}

/**
 * æ˜¾ç¤ºå•ä¸ªæœåŠ¡çš„æµ‹è¯•ç»“æœ
 */
function displayServiceResult(service: MCPService): void {
  const icon = service.status === 'online' ? 'âœ…' : 'âŒ';
  const color = service.status === 'online' ? 'green' : 'red';
  
  console.log(chalk[color](`${icon} ${service.name}`));
  console.log(chalk.gray(`   ç±»å‹: ${service.type}`));
  
  if (service.type === 'stdio') {
    console.log(chalk.gray(`   å‘½ä»¤: ${service.command} ${(service.args || []).join(' ')}`));
  } else {
    console.log(chalk.gray(`   ç«¯ç‚¹: ${service.endpoint}`));
  }
  
  if (service.status === 'online') {
    console.log(chalk.gray(`   å»¶è¿Ÿ: ${service.latency}ms`));
    if (service.version) {
      console.log(chalk.gray(`   ç‰ˆæœ¬: ${service.version}`));
    }
  } else {
    console.log(chalk.red(`   é”™è¯¯: ${service.error}`));
  }
  
  console.log(); // ç©ºè¡Œ
}

/**
 * æ˜¾ç¤ºæ±‡æ€»ä¿¡æ¯
 */
function displaySummary(services: MCPService[]): void {
  const onlineCount = services.filter(s => s.status === 'online').length;
  const offlineCount = services.filter(s => s.status === 'offline').length;
  const total = services.length;
  
  console.log(chalk.gray(`  æ€»è®¡: ${total} ä¸ªæœåŠ¡`));
  console.log(chalk.green(`  âœ… åœ¨çº¿: ${onlineCount}`));
  console.log(chalk.red(`  âŒ ç¦»çº¿: ${offlineCount}`));
  
  if (onlineCount > 0) {
    const avgLatency = services
      .filter(s => s.status === 'online' && s.latency)
      .reduce((sum, s) => sum + (s.latency || 0), 0) / onlineCount;
    console.log(chalk.gray(`  å¹³å‡å»¶è¿Ÿ: ${avgLatency.toFixed(0)}ms`));
  }
  
  const healthPercentage = (onlineCount / total * 100).toFixed(0);
  const healthColor = onlineCount === total ? 'green' : onlineCount > 0 ? 'yellow' : 'red';
  console.log(chalk[healthColor](`  å¥åº·åº¦: ${healthPercentage}%`));
}
