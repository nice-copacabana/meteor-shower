// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: 实现CLI mcp命令实际服务探测，检测和测试MCP服务可用性

import chalk from 'chalk';
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import os from 'os';

const execAsync = promisify(exec);

/**
 * MCP 服务信息
 */
interface MCPService {
  name: string;                  // 服务名称
  type: 'http' | 'stdio' | 'sse'; // 服务类型
  endpoint?: string;             // HTTP/SSE 端点
  command?: string;              // stdio 命令
  args?: string[];               // stdio 参数
  status?: 'online' | 'offline' | 'unknown'; // 服务状态
  latency?: number;              // 响应延迟(ms)
  error?: string;                // 错误信息
  version?: string;              // 服务版本
}

/**
 * MCP 配置文件格式
 */
interface MCPConfig {
  mcpServers: Record<string, {
    command: string;
    args?: string[];
    env?: Record<string, string>;
  }>;
}

/**
 * MCP 测试命令
 * 探测和测试配置的 MCP 服务可用性
 */
export async function mcpTestCommand() {
  console.log(chalk.cyan('🔧 测试 MCP 服务可用性...'));
  
  try {
    // 步骤1: 加载 MCP 配置
    console.log(chalk.gray('📚 加载 MCP 配置...'));
    const services = await loadMCPServices();
    
    if (services.length === 0) {
      console.log(chalk.yellow('\n⚠️ 未找到 MCP 服务配置'));
      console.log(chalk.gray('提示: 在 Claude Desktop 配置文件中添加 MCP 服务'));
      console.log(chalk.gray('配置文件位置:'));
      console.log(chalk.gray('  - macOS: ~/Library/Application Support/Claude/claude_desktop_config.json'));
      console.log(chalk.gray('  - Windows: %APPDATA%\\Claude\\claude_desktop_config.json'));
      return;
    }

    console.log(chalk.green(`✅ 发现 ${services.length} 个 MCP 服务\n`));

    // 步骤2: 测试每个服务
    console.log(chalk.cyan('🔍 正在测试服务...\n'));
    const results: MCPService[] = [];
    
    for (const service of services) {
      const result = await testMCPService(service);
      results.push(result);
      displayServiceResult(result);
    }

    // 步骤3: 显示汇总信息
    console.log(chalk.yellow('\n📊 MCP 服务状态汇总:'));
    displaySummary(results);

    // 步骤4: 提供故障排查建议
    const offlineServices = results.filter(s => s.status === 'offline');
    if (offlineServices.length > 0) {
      console.log(chalk.yellow('\n💡 故障排查建议:'));
      offlineServices.forEach(service => {
        console.log(chalk.gray(`\n  ${service.name}:`));
        if (service.type === 'stdio') {
          console.log(chalk.gray(`    1. 检查命令是否可用: ${service.command}`));
          console.log(chalk.gray(`    2. 验证依赖是否安装`));
          console.log(chalk.gray(`    3. 检查环境变量配置`));
        } else {
          console.log(chalk.gray(`    1. 检查服务是否运行: ${service.endpoint}`));
          console.log(chalk.gray(`    2. 验证网络连接`));
          console.log(chalk.gray(`    3. 检查防火墙设置`));
        }
      });
    }

  } catch (error: any) {
    console.error(chalk.red(`\n❌ 测试失败: ${error.message}`));
  }
}

/**
 * 加载 MCP 服务配置
 * 从 Claude Desktop 配置文件中读取 MCP 服务定义
 */
async function loadMCPServices(): Promise<MCPService[]> {
  const services: MCPService[] = [];
  
  // 确定配置文件路径
  const homeDir = os.homedir();
  const platform = os.platform();
  
  let configPath: string;
  if (platform === 'darwin') {
    configPath = path.join(homeDir, 'Library/Application Support/Claude/claude_desktop_config.json');
  } else if (platform === 'win32') {
    configPath = path.join(process.env.APPDATA || '', 'Claude', 'claude_desktop_config.json');
  } else {
    // Linux
    configPath = path.join(homeDir, '.config/Claude/claude_desktop_config.json');
  }

  try {
    // 读取配置文件
    const configContent = await fs.readFile(configPath, 'utf-8');
    const config: MCPConfig = JSON.parse(configContent);

    // 解析服务配置
    if (config.mcpServers) {
      for (const [name, serverConfig] of Object.entries(config.mcpServers)) {
        services.push({
          name,
          type: 'stdio',
          command: serverConfig.command,
          args: serverConfig.args || [],
          status: 'unknown'
        });
      }
    }
  } catch (error: any) {
    if (error.code === 'ENOENT') {
      // 配置文件不存在，返回默认服务列表用于测试
      return getDefaultMCPServices();
    }
    throw error;
  }

  return services;
}

/**
 * 获取默认 MCP 服务列表（用于演示）
 */
function getDefaultMCPServices(): MCPService[] {
  return [
    {
      name: 'filesystem',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-filesystem', process.cwd()],
      status: 'unknown'
    },
    {
      name: 'github',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-github'],
      status: 'unknown'
    },
    {
      name: 'brave-search',
      type: 'stdio',
      command: 'npx',
      args: ['-y', '@modelcontextprotocol/server-brave-search'],
      status: 'unknown'
    }
  ];
}

/**
 * 测试单个 MCP 服务
 */
async function testMCPService(service: MCPService): Promise<MCPService> {
  const startTime = Date.now();
  
  try {
    if (service.type === 'stdio') {
      // 测试 stdio 类型服务
      await testStdioService(service);
      service.latency = Date.now() - startTime;
      service.status = 'online';
    } else if (service.type === 'http' || service.type === 'sse') {
      // 测试 HTTP/SSE 类型服务
      await testHttpService(service);
      service.latency = Date.now() - startTime;
      service.status = 'online';
    }
  } catch (error: any) {
    service.status = 'offline';
    service.error = error.message;
    service.latency = Date.now() - startTime;
  }

  return service;
}

/**
 * 测试 stdio 类型 MCP 服务
 */
async function testStdioService(service: MCPService): Promise<void> {
  // 检查命令是否存在
  const command = service.command!;
  const testCommand = os.platform() === 'win32' 
    ? `where ${command}` 
    : `which ${command}`;
  
  try {
    await execAsync(testCommand);
    
    // 尝试启动服务并检测响应（超时 2 秒）
    const fullCommand = `${command} ${(service.args || []).join(' ')}`;
    const timeout = 2000;
    
    await Promise.race([
      execAsync(fullCommand, { timeout }),
      new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeout)
      )
    ]);
  } catch (error: any) {
    // Timeout 是预期的，因为 MCP 服务会持续运行
    if (error.message === 'Timeout' || error.killed) {
      return; // 服务正常启动
    }
    throw new Error(`命令不可用: ${command}`);
  }
}

/**
 * 测试 HTTP/SSE 类型 MCP 服务
 */
async function testHttpService(service: MCPService): Promise<void> {
  // TODO: 实现 HTTP 请求测试
  // const response = await fetch(service.endpoint!);
  // if (!response.ok) {
  //   throw new Error(`HTTP ${response.status}`);
  // }
  throw new Error('HTTP 服务测试尚未实现');
}

/**
 * 显示单个服务的测试结果
 */
function displayServiceResult(service: MCPService): void {
  const icon = service.status === 'online' ? '✅' : '❌';
  const color = service.status === 'online' ? 'green' : 'red';
  
  console.log(chalk[color](`${icon} ${service.name}`));
  console.log(chalk.gray(`   类型: ${service.type}`));
  
  if (service.type === 'stdio') {
    console.log(chalk.gray(`   命令: ${service.command} ${(service.args || []).join(' ')}`));
  } else {
    console.log(chalk.gray(`   端点: ${service.endpoint}`));
  }
  
  if (service.status === 'online') {
    console.log(chalk.gray(`   延迟: ${service.latency}ms`));
    if (service.version) {
      console.log(chalk.gray(`   版本: ${service.version}`));
    }
  } else {
    console.log(chalk.red(`   错误: ${service.error}`));
  }
  
  console.log(); // 空行
}

/**
 * 显示汇总信息
 */
function displaySummary(services: MCPService[]): void {
  const onlineCount = services.filter(s => s.status === 'online').length;
  const offlineCount = services.filter(s => s.status === 'offline').length;
  const total = services.length;
  
  console.log(chalk.gray(`  总计: ${total} 个服务`));
  console.log(chalk.green(`  ✅ 在线: ${onlineCount}`));
  console.log(chalk.red(`  ❌ 离线: ${offlineCount}`));
  
  if (onlineCount > 0) {
    const avgLatency = services
      .filter(s => s.status === 'online' && s.latency)
      .reduce((sum, s) => sum + (s.latency || 0), 0) / onlineCount;
    console.log(chalk.gray(`  平均延迟: ${avgLatency.toFixed(0)}ms`));
  }
  
  const healthPercentage = (onlineCount / total * 100).toFixed(0);
  const healthColor = onlineCount === total ? 'green' : onlineCount > 0 ? 'yellow' : 'red';
  console.log(chalk[healthColor](`  健康度: ${healthPercentage}%`));
}
