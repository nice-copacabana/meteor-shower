// Generated by Qoder AI (Model: claude-sonnet-4-5-20250929) - 2025-10-17
// Task: å®ç°M8ä»»åŠ¡ç®¡ç†CLIå‘½ä»¤ï¼ŒåŒ…å«ä»»åŠ¡åˆ›å»ºã€æäº¤ã€å–æ¶ˆã€æŸ¥çœ‹ç­‰æ ¸å¿ƒåŠŸèƒ½

/**
 * Taskå‘½ä»¤ - ä»»åŠ¡åè°ƒç®¡ç†
 * 
 * æä¾›ä»»åŠ¡çš„åˆ›å»ºã€æäº¤ã€å–æ¶ˆã€æŸ¥çœ‹ç­‰åŠŸèƒ½
 */

import { Command } from 'commander';
import inquirer from 'inquirer';
import chalk from 'chalk';
import ora from 'ora';
import Table from 'cli-table3';
import * as fs from 'fs-extra';
import * as path from 'path';
import Database from 'better-sqlite3';
import { TaskCoordinator, TaskPriority, CreateTaskParams } from '@meteor-shower/task-coordination';
import { initializeDatabase as initializeM8Database } from '@meteor-shower/task-coordination';

// é»˜è®¤æ•°æ®åº“è·¯å¾„
const DEFAULT_DB_PATH = path.join(process.cwd(), '.meteor-shower', 'tasks.db');

/**
 * è·å–TaskCoordinatorå®ä¾‹
 */
function getTaskCoordinator(): TaskCoordinator {
  fs.ensureDirSync(path.dirname(DEFAULT_DB_PATH));
  const db = new Database(DEFAULT_DB_PATH);
  initializeM8Database(db);
  return new TaskCoordinator(db);
}

/**
 * è·å–å½“å‰ç”¨æˆ·IDï¼ˆä¸´æ—¶å®ç°ï¼‰
 */
function getCurrentUserId(): string {
  // TODO: ä»ç”¨æˆ·è®¤è¯ç³»ç»Ÿè·å–
  return 'demo-user-001';
}

/**
 * taskå‘½ä»¤ä¸»å…¥å£
 */
export function createTaskCommand(): Command {
  const taskCmd = new Command('task')
    .description('ä»»åŠ¡åè°ƒç®¡ç†');

  // task create - åˆ›å»ºä»»åŠ¡
  taskCmd
    .command('create')
    .description('åˆ›å»ºæ–°ä»»åŠ¡')
    .option('-i, --interactive', 'äº¤äº’å¼åˆ›å»º', true)
    .option('--title <title>', 'ä»»åŠ¡æ ‡é¢˜')
    .option('--desc <description>', 'ä»»åŠ¡æè¿°')
    .option('--tool <tool>', 'ä½¿ç”¨çš„å·¥å…·åç§°')
    .option('--priority <priority>', 'ä¼˜å…ˆçº§ (LOW|MEDIUM|HIGH|URGENT)', 'MEDIUM')
    .option('--timeout <minutes>', 'è¶…æ—¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰', '60')
    .action(async (options) => {
      try {
        if (options.interactive && !options.title) {
          await createTaskInteractive();
        } else {
          await createTaskDirect(options);
        }
      } catch (error: any) {
        console.error(chalk.red('âœ— åˆ›å»ºå¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task list - åˆ—å‡ºä»»åŠ¡
  taskCmd
    .command('list')
    .description('åˆ—å‡ºä»»åŠ¡')
    .option('-s, --status <status>', 'æŒ‰çŠ¶æ€ç­›é€‰ (DRAFT|SUBMITTED|RUNNING|COMPLETED|FAILED|CANCELLED)')
    .option('-p, --priority <priority>', 'æŒ‰ä¼˜å…ˆçº§ç­›é€‰ (LOW|MEDIUM|HIGH|URGENT)')
    .option('--page <number>', 'é¡µç ', '1')
    .option('--size <number>', 'æ¯é¡µæ•°é‡', '20')
    .action(async (options) => {
      try {
        await listTasks(options);
      } catch (error: any) {
        console.error(chalk.red('âœ— æŸ¥è¯¢å¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task show - æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…
  taskCmd
    .command('show <taskId>')
    .description('æ˜¾ç¤ºä»»åŠ¡è¯¦ç»†ä¿¡æ¯')
    .option('-h, --history', 'æ˜¾ç¤ºæ‰§è¡Œå†å²')
    .option('-d, --dependencies', 'æ˜¾ç¤ºä¾èµ–å…³ç³»')
    .action(async (taskId, options) => {
      try {
        await showTask(taskId, options);
      } catch (error: any) {
        console.error(chalk.red('âœ— æŸ¥è¯¢å¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task submit - æäº¤ä»»åŠ¡
  taskCmd
    .command('submit <taskId>')
    .description('æäº¤ä»»åŠ¡æ‰§è¡Œ')
    .action(async (taskId) => {
      try {
        await submitTask(taskId);
      } catch (error: any) {
        console.error(chalk.red('âœ— æäº¤å¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task cancel - å–æ¶ˆä»»åŠ¡
  taskCmd
    .command('cancel <taskId>')
    .description('å–æ¶ˆä»»åŠ¡')
    .option('-y, --yes', 'è·³è¿‡ç¡®è®¤')
    .action(async (taskId, options) => {
      try {
        await cancelTask(taskId, options);
      } catch (error: any) {
        console.error(chalk.red('âœ— å–æ¶ˆå¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task add-dep - æ·»åŠ ä»»åŠ¡ä¾èµ–
  taskCmd
    .command('add-dep <taskId> <dependsOnTaskId>')
    .description('æ·»åŠ ä»»åŠ¡ä¾èµ–å…³ç³»')
    .action(async (taskId, dependsOnTaskId) => {
      try {
        await addDependency(taskId, dependsOnTaskId);
      } catch (error: any) {
        console.error(chalk.red('âœ— æ·»åŠ ä¾èµ–å¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  // task deps - æŸ¥çœ‹ä»»åŠ¡ä¾èµ–
  taskCmd
    .command('deps <taskId>')
    .description('æŸ¥çœ‹ä»»åŠ¡ä¾èµ–å…³ç³»')
    .action(async (taskId) => {
      try {
        await showDependencies(taskId);
      } catch (error: any) {
        console.error(chalk.red('âœ— æŸ¥è¯¢å¤±è´¥:'), error.message);
        process.exit(1);
      }
    });

  return taskCmd;
}

/**
 * äº¤äº’å¼åˆ›å»ºä»»åŠ¡
 */
async function createTaskInteractive(): Promise<void> {
  console.log(chalk.cyan.bold('\nğŸ“‹ åˆ›å»ºæ–°ä»»åŠ¡\n'));

  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'title',
      message: 'ä»»åŠ¡æ ‡é¢˜:',
      validate: (input) => input.trim().length > 0 || 'æ ‡é¢˜ä¸èƒ½ä¸ºç©º'
    },
    {
      type: 'input',
      name: 'description',
      message: 'ä»»åŠ¡æè¿°:'
    },
    {
      type: 'input',
      name: 'toolName',
      message: 'ä½¿ç”¨çš„å·¥å…·åç§°:',
      default: 'meteor-shower',
      validate: (input) => input.trim().length > 0 || 'å·¥å…·åç§°ä¸èƒ½ä¸ºç©º'
    },
    {
      type: 'list',
      name: 'priority',
      message: 'ä¼˜å…ˆçº§:',
      choices: [
        { name: 'ğŸ”µ ä½ (LOW)', value: 'LOW' },
        { name: 'ğŸŸ¢ ä¸­ (MEDIUM)', value: 'MEDIUM' },
        { name: 'ğŸŸ¡ é«˜ (HIGH)', value: 'HIGH' },
        { name: 'ğŸ”´ ç´§æ€¥ (URGENT)', value: 'URGENT' }
      ],
      default: 'MEDIUM'
    },
    {
      type: 'number',
      name: 'timeoutMinutes',
      message: 'è¶…æ—¶æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰:',
      default: 60,
      validate: (input) => input > 0 || 'è¶…æ—¶æ—¶é—´å¿…é¡»å¤§äº0'
    }
  ]);

  const spinner = ora('æ­£åœ¨åˆ›å»ºä»»åŠ¡...').start();

  const coordinator = getTaskCoordinator();
  const userId = getCurrentUserId();

  const params: CreateTaskParams = {
    title: answers.title,
    description: answers.description,
    toolName: answers.toolName,
    priority: answers.priority as TaskPriority,
    timeoutMinutes: answers.timeoutMinutes,
    userId
  };

  const task = coordinator.createTask(params);

  spinner.succeed(chalk.green('ä»»åŠ¡åˆ›å»ºæˆåŠŸï¼'));

  console.log(chalk.cyan('\nä»»åŠ¡ä¿¡æ¯:'));
  console.log(chalk.gray('â”€'.repeat(50)));
  console.log(chalk.white('ID:       ') + chalk.yellow(task.id));
  console.log(chalk.white('æ ‡é¢˜:     ') + task.title);
  console.log(chalk.white('çŠ¶æ€:     ') + formatStatus(task.status));
  console.log(chalk.white('ä¼˜å…ˆçº§:   ') + formatPriority(task.priority));
  console.log(chalk.gray('â”€'.repeat(50)));

  console.log(chalk.cyan('\nğŸ’¡ æç¤º: ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æäº¤ä»»åŠ¡:'));
  console.log(chalk.white(`   meteor-shower task submit ${task.id}\n`));
}

/**
 * ç›´æ¥åˆ›å»ºä»»åŠ¡ï¼ˆéäº¤äº’å¼ï¼‰
 */
async function createTaskDirect(options: any): Promise<void> {
  if (!options.title || !options.tool) {
    console.error(chalk.red('âœ— é”™è¯¯: --title å’Œ --tool å‚æ•°æ˜¯å¿…éœ€çš„'));
    process.exit(1);
  }

  const coordinator = getTaskCoordinator();
  const userId = getCurrentUserId();

  const params: CreateTaskParams = {
    title: options.title,
    description: options.desc,
    toolName: options.tool,
    priority: options.priority as TaskPriority,
    timeoutMinutes: parseInt(options.timeout),
    userId
  };

  const task = coordinator.createTask(params);

  console.log(chalk.green('âœ“ ä»»åŠ¡åˆ›å»ºæˆåŠŸ'));
  console.log(chalk.white('ä»»åŠ¡ID: ') + chalk.yellow(task.id));
}

/**
 * åˆ—å‡ºä»»åŠ¡
 */
async function listTasks(options: any): Promise<void> {
  const coordinator = getTaskCoordinator();
  const userId = getCurrentUserId();

  const { tasks, total } = coordinator.listUserTasks(userId, {
    status: options.status,
    priority: options.priority,
    page: parseInt(options.page),
    pageSize: parseInt(options.size)
  });

  if (tasks.length === 0) {
    console.log(chalk.yellow('\næš‚æ— ä»»åŠ¡'));
    return;
  }

  console.log(chalk.cyan.bold(`\nğŸ“‹ ä»»åŠ¡åˆ—è¡¨ (å…± ${total} ä¸ªä»»åŠ¡)\n`));

  const table = new Table({
    head: ['ID', 'æ ‡é¢˜', 'çŠ¶æ€', 'ä¼˜å…ˆçº§', 'å·¥å…·', 'åˆ›å»ºæ—¶é—´'].map(h => chalk.cyan.bold(h)),
    colWidths: [38, 30, 12, 10, 15, 20]
  });

  for (const task of tasks) {
    table.push([
      task.id.substring(0, 8) + '...',
      task.title.length > 28 ? task.title.substring(0, 25) + '...' : task.title,
      formatStatus(task.status),
      formatPriority(task.priority),
      task.tool_name,
      new Date(task.created_at).toLocaleString('zh-CN')
    ]);
  }

  console.log(table.toString());

  const page = parseInt(options.page);
  const pageSize = parseInt(options.size);
  const totalPages = Math.ceil(total / pageSize);

  if (totalPages > 1) {
    console.log(chalk.gray(`\nç¬¬ ${page}/${totalPages} é¡µ`));
  }

  console.log(chalk.cyan('\nğŸ’¡ æç¤º: ä½¿ç”¨ meteor-shower task show <ID> æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…\n'));
}

/**
 * æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…
 */
async function showTask(taskId: string, options: any): Promise<void> {
  const coordinator = getTaskCoordinator();
  const task = coordinator.getTaskById(taskId);

  if (!task) {
    console.error(chalk.red(`âœ— ä»»åŠ¡ ${taskId} ä¸å­˜åœ¨`));
    process.exit(1);
  }

  console.log(chalk.cyan.bold('\nğŸ“‹ ä»»åŠ¡è¯¦æƒ…\n'));
  console.log(chalk.gray('â”€'.repeat(60)));
  console.log(chalk.white('ID:           ') + chalk.yellow(task.id));
  console.log(chalk.white('æ ‡é¢˜:         ') + task.title);
  console.log(chalk.white('æè¿°:         ') + (task.description || chalk.gray('æ— ')));
  console.log(chalk.white('çŠ¶æ€:         ') + formatStatus(task.status));
  console.log(chalk.white('ä¼˜å…ˆçº§:       ') + formatPriority(task.priority));
  console.log(chalk.white('å·¥å…·:         ') + task.tool_name);
  console.log(chalk.white('é…ç½®ID:       ') + (task.config_id || chalk.gray('æ— ')));
  console.log(chalk.white('åˆ›å»ºæ—¶é—´:     ') + new Date(task.created_at).toLocaleString('zh-CN'));

  if (task.started_at) {
    console.log(chalk.white('å¼€å§‹æ—¶é—´:     ') + new Date(task.started_at).toLocaleString('zh-CN'));
  }

  if (task.completed_at) {
    console.log(chalk.white('å®Œæˆæ—¶é—´:     ') + new Date(task.completed_at).toLocaleString('zh-CN'));
    const duration = task.completed_at - task.started_at!;
    console.log(chalk.white('æ‰§è¡Œæ—¶é•¿:     ') + formatDuration(duration));
  }

  console.log(chalk.white('è¶…æ—¶æ—¶é—´:     ') + new Date(task.timeout_at).toLocaleString('zh-CN'));

  if (task.result) {
    console.log(chalk.white('ç»“æœ:         ') + chalk.green(task.result));
  }

  if (task.error_message) {
    console.log(chalk.white('é”™è¯¯ä¿¡æ¯:     ') + chalk.red(task.error_message));
  }

  console.log(chalk.gray('â”€'.repeat(60)));

  // æ˜¾ç¤ºä¾èµ–å…³ç³»
  if (options.dependencies) {
    const deps = coordinator.getDependencies(taskId);
    if (deps.length > 0) {
      console.log(chalk.cyan.bold('\nğŸ”— ä¾èµ–ä»»åŠ¡:\n'));
      for (const dep of deps) {
        const depTask = coordinator.getTaskById(dep.depends_on_task_id);
        console.log(chalk.white('  â†’ ') + (depTask ? `${depTask.title} (${formatStatus(depTask.status)})` : dep.depends_on_task_id));
      }
    }
  }

  // æ˜¾ç¤ºæ‰§è¡Œå†å²
  if (options.history) {
    const history = coordinator.getExecutionHistory(taskId);
    if (history.length > 0) {
      console.log(chalk.cyan.bold('\nğŸ“Š æ‰§è¡Œå†å²:\n'));
      const historyTable = new Table({
        head: ['å°è¯•æ¬¡æ•°', 'ç»“æœ', 'æ‰§è¡Œæ—¶é•¿', 'åˆ›å»ºæ—¶é—´'].map(h => chalk.cyan.bold(h))
      });

      for (const exec of history) {
        historyTable.push([
          `#${exec.attempt}`,
          exec.result ? chalk.green('æˆåŠŸ') : chalk.red('å¤±è´¥'),
          exec.execution_time ? formatDuration(exec.execution_time) : chalk.gray('N/A'),
          new Date(exec.created_at).toLocaleString('zh-CN')
        ]);
      }

      console.log(historyTable.toString());
    }
  }

  console.log();
}

/**
 * æäº¤ä»»åŠ¡
 */
async function submitTask(taskId: string): Promise<void> {
  const coordinator = getTaskCoordinator();
  const userId = getCurrentUserId();

  const spinner = ora('æ­£åœ¨æäº¤ä»»åŠ¡...').start();

  try {
    coordinator.submitTask(taskId, userId);
    spinner.succeed(chalk.green('ä»»åŠ¡æäº¤æˆåŠŸï¼'));

    // æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³
    const depsMet = coordinator.checkDependenciesMet(taskId);
    if (!depsMet) {
      console.log(chalk.yellow('\nâš ï¸  è­¦å‘Š: ä»»åŠ¡ä¾èµ–å°šæœªå…¨éƒ¨å®Œæˆï¼Œä»»åŠ¡å°†ç­‰å¾…ä¾èµ–å®Œæˆåæ‰§è¡Œ'));
    } else {
      console.log(chalk.cyan('\nâœ“ æ‰€æœ‰ä¾èµ–å·²æ»¡è¶³ï¼Œä»»åŠ¡å·²è¿›å…¥å¾…æ‰§è¡Œé˜Ÿåˆ—'));
    }
  } catch (error: any) {
    spinner.fail(chalk.red('æäº¤å¤±è´¥'));
    throw error;
  }
}

/**
 * å–æ¶ˆä»»åŠ¡
 */
async function cancelTask(taskId: string, options: any): Promise<void> {
  const coordinator = getTaskCoordinator();
  const userId = getCurrentUserId();

  if (!options.yes) {
    const { confirmed } = await inquirer.prompt([{
      type: 'confirm',
      name: 'confirmed',
      message: `ç¡®è®¤è¦å–æ¶ˆä»»åŠ¡ ${taskId.substring(0, 8)}... å—ï¼Ÿ`,
      default: false
    }]);

    if (!confirmed) {
      console.log(chalk.yellow('å·²å–æ¶ˆæ“ä½œ'));
      return;
    }
  }

  const spinner = ora('æ­£åœ¨å–æ¶ˆä»»åŠ¡...').start();

  try {
    coordinator.cancelTask(taskId, userId);
    spinner.succeed(chalk.green('ä»»åŠ¡å·²å–æ¶ˆ'));
  } catch (error: any) {
    spinner.fail(chalk.red('å–æ¶ˆå¤±è´¥'));
    throw error;
  }
}

/**
 * æ·»åŠ ä»»åŠ¡ä¾èµ–
 */
async function addDependency(taskId: string, dependsOnTaskId: string): Promise<void> {
  const coordinator = getTaskCoordinator();

  // éªŒè¯ä¸¤ä¸ªä»»åŠ¡éƒ½å­˜åœ¨
  const task = coordinator.getTaskById(taskId);
  const depTask = coordinator.getTaskById(dependsOnTaskId);

  if (!task) {
    console.error(chalk.red(`âœ— ä»»åŠ¡ ${taskId} ä¸å­˜åœ¨`));
    process.exit(1);
  }

  if (!depTask) {
    console.error(chalk.red(`âœ— ä¾èµ–ä»»åŠ¡ ${dependsOnTaskId} ä¸å­˜åœ¨`));
    process.exit(1);
  }

  const spinner = ora('æ­£åœ¨æ·»åŠ ä¾èµ–å…³ç³»...').start();

  try {
    coordinator.addDependency(taskId, dependsOnTaskId);
    spinner.succeed(chalk.green('ä¾èµ–å…³ç³»æ·»åŠ æˆåŠŸ'));

    console.log(chalk.cyan('\nä¾èµ–å…³ç³»:'));
    console.log(chalk.white(`  ${task.title} â†’ ${depTask.title}`));
    console.log();
  } catch (error: any) {
    spinner.fail(chalk.red('æ·»åŠ å¤±è´¥'));
    throw error;
  }
}

/**
 * æ˜¾ç¤ºä»»åŠ¡ä¾èµ–
 */
async function showDependencies(taskId: string): Promise<void> {
  const coordinator = getTaskCoordinator();
  const task = coordinator.getTaskById(taskId);

  if (!task) {
    console.error(chalk.red(`âœ— ä»»åŠ¡ ${taskId} ä¸å­˜åœ¨`));
    process.exit(1);
  }

  const deps = coordinator.getDependencies(taskId);

  console.log(chalk.cyan.bold(`\nğŸ”— ä»»åŠ¡ä¾èµ–: ${task.title}\n`));

  if (deps.length === 0) {
    console.log(chalk.gray('  è¯¥ä»»åŠ¡æ²¡æœ‰ä¾èµ–é¡¹\n'));
    return;
  }

  const table = new Table({
    head: ['ä¾èµ–ä»»åŠ¡ID', 'ä»»åŠ¡æ ‡é¢˜', 'çŠ¶æ€', 'åˆ›å»ºæ—¶é—´'].map(h => chalk.cyan.bold(h)),
    colWidths: [38, 30, 12, 20]
  });

  for (const dep of deps) {
    const depTask = coordinator.getTaskById(dep.depends_on_task_id);
    if (depTask) {
      table.push([
        depTask.id.substring(0, 8) + '...',
        depTask.title.length > 28 ? depTask.title.substring(0, 25) + '...' : depTask.title,
        formatStatus(depTask.status),
        new Date(dep.created_at).toLocaleString('zh-CN')
      ]);
    }
  }

  console.log(table.toString());

  const depsMet = coordinator.checkDependenciesMet(taskId);
  if (depsMet) {
    console.log(chalk.green('\nâœ“ æ‰€æœ‰ä¾èµ–å·²æ»¡è¶³\n'));
  } else {
    console.log(chalk.yellow('\nâš ï¸  éƒ¨åˆ†ä¾èµ–å°šæœªå®Œæˆ\n'));
  }
}

/**
 * æ ¼å¼åŒ–çŠ¶æ€
 */
function formatStatus(status: string): string {
  const statusMap: Record<string, { icon: string; color: any }> = {
    DRAFT: { icon: 'ğŸ“', color: chalk.gray },
    SUBMITTED: { icon: 'ğŸ“¤', color: chalk.blue },
    RUNNING: { icon: 'âš™ï¸', color: chalk.cyan },
    COMPLETED: { icon: 'âœ…', color: chalk.green },
    REVIEWING: { icon: 'ğŸ‘€', color: chalk.magenta },
    APPROVED: { icon: 'âœ”ï¸', color: chalk.green },
    REJECTED: { icon: 'âŒ', color: chalk.red },
    CANCELLED: { icon: 'ğŸš«', color: chalk.yellow },
    FAILED: { icon: 'ğŸ’¥', color: chalk.red }
  };

  const statusInfo = statusMap[status] || { icon: 'â“', color: chalk.white };
  return statusInfo.color(`${statusInfo.icon} ${status}`);
}

/**
 * æ ¼å¼åŒ–ä¼˜å…ˆçº§
 */
function formatPriority(priority: string): string {
  const priorityMap: Record<string, { icon: string; color: any }> = {
    LOW: { icon: 'ğŸ”µ', color: chalk.blue },
    MEDIUM: { icon: 'ğŸŸ¢', color: chalk.green },
    HIGH: { icon: 'ğŸŸ¡', color: chalk.yellow },
    URGENT: { icon: 'ğŸ”´', color: chalk.red }
  };

  const priorityInfo = priorityMap[priority] || { icon: 'âšª', color: chalk.white };
  return priorityInfo.color(`${priorityInfo.icon} ${priority}`);
}

/**
 * æ ¼å¼åŒ–æ—¶é•¿
 */
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}å°æ—¶${minutes % 60}åˆ†é’Ÿ`;
  } else if (minutes > 0) {
    return `${minutes}åˆ†é’Ÿ${seconds % 60}ç§’`;
  } else {
    return `${seconds}ç§’`;
  }
}
