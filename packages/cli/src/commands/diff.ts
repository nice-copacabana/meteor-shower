// Generated by Qoder AI (Model: claude-sonnet-4-20250514) - 2025-10-14
// Task: å¢å¼ºCLI diffå‘½ä»¤æ˜¾ç¤ºæ ¼å¼ï¼ˆå½©è‰²è¾“å‡ºã€è¡¨æ ¼å±•ç¤ºï¼‰

import chalk from 'chalk';
import fs from 'fs/promises';
import path from 'path';
import Table from 'cli-table3';
import { createAdapter } from '@meteor-shower/adapters';

interface ChangeDetail {
  path: string;
  kind: 'create' | 'update' | 'delete';
  tool: string;
  size?: string;
  description?: string;
}

export async function diffCommand() {
  console.log(chalk.cyan.bold('\nğŸ” åˆ†æé…ç½®å·®å¼‚\n'));
  console.log(chalk.gray('â”€'.repeat(60)));
  
  try {
    // è¯»å–é…ç½®è®¡åˆ’
    const planPath = path.join(process.cwd(), '.meteor-shower', 'config-plan.json');
    const planContent = await fs.readFile(planPath, 'utf-8');
    const configPlan = JSON.parse(planContent);
    
    // æ˜¾ç¤ºé…ç½®ä¿¡æ¯
    console.log(chalk.white('\né…ç½®è®¡åˆ’ä¿¡æ¯:'));
    console.log(chalk.gray(`  æ¨¡æ¿:     ${chalk.cyan(configPlan.template)}`));
    console.log(chalk.gray(`  å·¥å…·é›†:   ${chalk.cyan(configPlan.toolset.join(', '))}`));
    console.log(chalk.gray(`  å˜é‡æ•°:   ${chalk.cyan(Object.keys(configPlan.variables).length)}`));
    
    // å¯¹æ¯ä¸ªå·¥å…·è·å–å·®å¼‚
    const allChanges: ChangeDetail[] = [];
    
    console.log(chalk.gray('\næ­£åœ¨åˆ†æé…ç½®å·®å¼‚...'));
    
    for (const tool of configPlan.toolset) {
      const adapter = createAdapter(tool);
      const diffResult = await adapter.plan({
        target: tool,
        dryRun: true,
        variables: configPlan.variables
      });
      
      // ä¸ºæ¯ä¸ªå˜æ›´æ·»åŠ å·¥å…·ä¿¡æ¯
      const changesWithTool = diffResult.changes.map((change: any) => ({
        ...change,
        tool: tool
      }));
      
      allChanges.push(...changesWithTool);
    }
    
    // ç»Ÿè®¡ä¿¡æ¯
    const createCount = allChanges.filter(c => c.kind === 'create').length;
    const updateCount = allChanges.filter(c => c.kind === 'update').length;
    const deleteCount = allChanges.filter(c => c.kind === 'delete').length;
    
    // æ˜¾ç¤ºç»Ÿè®¡æ‘˜è¦
    console.log(chalk.cyan('\nğŸ“Š å˜æ›´ç»Ÿè®¡:\n'));
    const statsTable = new Table({
      head: [chalk.white.bold('ç±»å‹'), chalk.white.bold('æ•°é‡'), chalk.white.bold('è¯´æ˜')],
      colWidths: [15, 10, 35],
      style: {
        head: [],
        border: ['gray']
      }
    });
    
    if (createCount > 0) {
      statsTable.push([
        chalk.green('âœ¨ æ–°å»º'),
        chalk.green.bold(createCount),
        chalk.gray('å°†åˆ›å»ºæ–°é…ç½®æ–‡ä»¶')
      ]);
    }
    
    if (updateCount > 0) {
      statsTable.push([
        chalk.yellow('ğŸ”„ æ›´æ–°'),
        chalk.yellow.bold(updateCount),
        chalk.gray('å°†æ›´æ–°ç°æœ‰é…ç½®æ–‡ä»¶')
      ]);
    }
    
    if (deleteCount > 0) {
      statsTable.push([
        chalk.red('ğŸ—‘ï¸  åˆ é™¤'),
        chalk.red.bold(deleteCount),
        chalk.gray('å°†åˆ é™¤é…ç½®æ–‡ä»¶')
      ]);
    }
    
    statsTable.push([
      chalk.cyan.bold('æ€»è®¡'),
      chalk.cyan.bold(allChanges.length),
      chalk.gray('é…ç½®æ–‡ä»¶æ€»æ•°')
    ]);
    
    console.log(statsTable.toString());
    
    // æ˜¾ç¤ºè¯¦ç»†å˜æ›´è¡¨æ ¼
    if (allChanges.length > 0) {
      console.log(chalk.cyan('\nğŸ“‹ è¯¦ç»†å˜æ›´åˆ—è¡¨:\n'));
      
      const changesTable = new Table({
        head: [
          chalk.white.bold('æ“ä½œ'),
          chalk.white.bold('å·¥å…·'),
          chalk.white.bold('æ–‡ä»¶è·¯å¾„')
        ],
        colWidths: [8, 12, 50],
        style: {
          head: [],
          border: ['gray']
        },
        wordWrap: true
      });
      
      // æŒ‰å·¥å…·åˆ†ç»„æ˜¾ç¤º
      const groupedByTool: Record<string, ChangeDetail[]> = {};
      allChanges.forEach(change => {
        if (!groupedByTool[change.tool]) {
          groupedByTool[change.tool] = [];
        }
        groupedByTool[change.tool].push(change);
      });
      
      // ä¸ºæ¯ä¸ªå·¥å…·æ·»åŠ å˜æ›´
      Object.entries(groupedByTool).forEach(([tool, changes]) => {
        changes.forEach((change, index) => {
          const kindIcon = getKindIcon(change.kind);
          const kindColor = getKindColor(change.kind);
          
          changesTable.push([
            chalk[kindColor](kindIcon),
            index === 0 ? chalk.cyan.bold(tool.toUpperCase()) : '',
            chalk.gray(change.path)
          ]);
        });
      });
      
      console.log(changesTable.toString());
    }
    
    // æ˜¾ç¤ºæ–‡ä»¶ä½ç½®ä¿¡æ¯
    console.log(chalk.cyan('\nğŸ“ æ–‡ä»¶ä½ç½®è¯´æ˜:\n'));
    const locationTable = new Table({
      colWidths: [20, 50],
      style: {
        border: ['gray']
      }
    });
    
    locationTable.push(
      [chalk.yellow('~/.gemini/'), chalk.gray('Gemini å…¨å±€é…ç½®ç›®å½•')],
      [chalk.yellow('~/.claude/'), chalk.gray('Claude å…¨å±€é…ç½®ç›®å½•')],
      [chalk.yellow('./.cursor/'), chalk.gray('Cursor é¡¹ç›®é…ç½®ç›®å½•')],
      [chalk.yellow('./'), chalk.gray('é¡¹ç›®æ ¹ç›®å½•é…ç½®æ–‡ä»¶')]
    );
    
    console.log(locationTable.toString());
    
    // ä¸‹ä¸€æ­¥æç¤º
    console.log(chalk.cyan('\nğŸ¯ ä¸‹ä¸€æ­¥æ“ä½œ:\n'));
    console.log(chalk.white('  1. æ£€æŸ¥ä¸Šè¿°å˜æ›´æ˜¯å¦ç¬¦åˆé¢„æœŸ'));
    console.log(chalk.white('  2. è¿è¡Œ ' + chalk.yellow.bold('ms apply') + ' åº”ç”¨è¿™äº›å˜æ›´'));
    console.log(chalk.white('  3. è¿è¡Œ ' + chalk.yellow.bold('ms apply --dry-run') + ' æ¨¡æ‹Ÿåº”ç”¨è¿‡ç¨‹'));
    console.log(chalk.gray('\nâ”€'.repeat(60)));
    console.log('');
    
  } catch (error: any) {
    console.log(chalk.gray('\nâ”€'.repeat(60)));
    if (error.code === 'ENOENT') {
      console.error(chalk.red.bold('\nâŒ é”™è¯¯: æœªæ‰¾åˆ°é…ç½®è®¡åˆ’æ–‡ä»¶\n'));
      console.log(chalk.yellow('ğŸ’¡ å»ºè®®æ“ä½œ:'));
      console.log(chalk.white('  1. è¿è¡Œ ' + chalk.cyan.bold('ms init') + ' åˆå§‹åŒ–é…ç½®'));
      console.log(chalk.white('  2. å®Œæˆé…ç½®å‘å¯¼åå†è¿è¡Œ diff å‘½ä»¤'));
    } else {
      console.error(chalk.red.bold('\nâŒ åˆ†æé…ç½®å·®å¼‚å¤±è´¥\n'));
      console.error(chalk.red('é”™è¯¯è¯¦æƒ…:'), error.message);
      if (error.stack) {
        console.log(chalk.gray('\nå †æ ˆè·Ÿè¸ª:'));
        console.log(chalk.gray(error.stack));
      }
    }
    console.log('');
  }
}

/**
 * æ ¹æ®å˜æ›´ç±»å‹è·å–å›¾æ ‡
 */
function getKindIcon(kind: string): string {
  switch (kind) {
    case 'create': return 'âœ¨';
    case 'update': return 'ğŸ”„';
    case 'delete': return 'ğŸ—‘ï¸';
    default: return 'â“';
  }
}

/**
 * æ ¹æ®å˜æ›´ç±»å‹è·å–é¢œè‰²
 */
function getKindColor(kind: string): 'green' | 'yellow' | 'red' | 'gray' {
  switch (kind) {
    case 'create': return 'green';
    case 'update': return 'yellow';
    case 'delete': return 'red';
    default: return 'gray';
  }
}
